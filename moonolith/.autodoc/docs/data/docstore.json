[["0",{"pageContent":"[View code on GitHub](https://github.com/LaGuerrePiece/moonolith/index.html)\n\nThe code provided is an HTML file that serves as the entry point for the Moonolith project. It sets up the basic structure of an HTML document and includes a JavaScript file called \"main.js\" using the `<script>` tag.\n\nThe purpose of this code is to create a web page that will be displayed in a web browser. The HTML file defines the structure and content of the page, while the JavaScript file contains the logic and functionality that will be executed when the page is loaded.\n\nLet's break down the code:\n\n- `<!DOCTYPE html>`: This is the document type declaration and specifies that the document is an HTML file.\n- `<html lang=\"en\">`: This is the opening tag for the HTML document. The `lang` attribute specifies the language of the document (English in this case).\n- `<head>`: This is the opening tag for the head section of the document. The head section contains meta information and external resources used by the page.\n- `<meta charset=\"UTF-8\" />`: This meta tag specifies the character encoding for the document (UTF-8).\n- `<link rel=\"icon\" href=\"/favicon.ico\" />`: This link tag specifies the location of the favicon (the small icon displayed in the browser tab).\n- `<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />`: This meta tag sets the viewport properties, which control how the page is displayed on different devices.\n- `<title>m o o n o l i t h </title>`: This is the title of the web page, which will be displayed in the browser's title bar or tab.\n- `<body style=\"margin: 0; padding: 0\">`: This is the opening tag for the body section of the document. The body section contains the visible content of the page.\n- `<script type=\"module\" src=\"./src/main.js\"></script>`: This script tag includes the JavaScript file \"main.js\" using the `src` attribute. The `type=\"module\"` attribute indicates that the JavaScript file is a module, which allows for the use of modern JavaScript features and modules.\n\nIn the larger Moonolith project, this HTML file serves as the starting point for the web application. It defines the basic structure of the page and includes the main JavaScript file that contains the application's logic. Other HTML, CSS, and JavaScript files can be added and linked to this file to build out the complete web application.\n## Questions: \n 1. **What is the purpose of the `meta` tag with `charset=\"UTF-8\"`?**\nThe `meta` tag with `charset=\"UTF-8\"` specifies the character encoding for the HTML document, ensuring that the browser correctly interprets and displays characters from the UTF-8 character set.\n\n2. **What is the significance of the `link` tag with `rel=\"icon\"` and `href=\"/favicon.ico\"`?**\nThe `link` tag with `rel=\"icon\"` and `href=\"/favicon.ico\"` specifies the location of the favicon (short for \"favorite icon\") for the website. The favicon is the small icon that appears in the browser tab or next to the page title in bookmarks.\n\n3. **What is the purpose of the `type=\"module\"` attribute in the `script` tag?**\nThe `type=\"module\"` attribute in the `script` tag indicates that the JavaScript file being loaded (`./src/main.js`) is a module. This allows the use of ES6 module syntax and enables features such as `import` and `export` statements.","metadata":{"source":".autodoc/docs/markdown/index.md"}}],["1",{"pageContent":"[View code on GitHub](https://github.com/LaGuerrePiece/moonolith/server/index.js)\n\nThe code provided is a basic Node.js server using the Express framework. It sets up a server that listens on port 3001 and handles two different routes: the homepage (\"/\") and \"/liste\".\n\nWhen a GET request is made to the homepage (\"/\"), the server responds with the string \"hello world\". This is a simple example of a route handler in Express:\n\n```javascript\napp.get('/', function(req, res) {\n    res.send('hello world');\n});\n```\n\nWhen a GET request is made to the \"/liste\" route, the server reads the contents of a file called \"liste.txt\" and sends the contents as the response. This is done using the `fs.readFile` function, which reads the file asynchronously. The contents of the file are then sent as the response to the client. If an error occurs while reading the file, the error is logged to the console.\n\n```javascript\napp.get('/liste', function(req, res) {\n    fs.readFile('liste.txt', { encoding: \"utf8\" }, function(err, data) {\n        if (err) {\n            console.log(err)\n        }\n        console.log(data);\n        res.send(data);\n    })\n})\n```\n\nThis code can be used as a starting point for building a server-side application that serves static files and handles different routes. It demonstrates how to set up a basic server using Express and how to handle different HTTP requests.\n\nIn the larger project, this code could be expanded to include more routes and functionality. For example, additional routes could be added to handle POST requests or to interact with a database. Middleware could also be added to perform tasks such as authentication or logging. The server could be used to serve static files, handle API requests, or render dynamic web pages.\n\nOverall, this code provides a foundation for building a server-side application using Node.js and Express. It demonstrates how to handle different routes and perform tasks such as reading files.\n## Questions: \n 1. What is the purpose of the `express` module in this code?\n- The `express` module is used to create an instance of an Express application, which allows the code to handle HTTP requests and responses.\n\n2. What is the purpose of the `fs` module in this code?\n- The `fs` module is used to read the contents of a file. In this code, it is used to read the contents of the file `liste.txt`.\n\n3. Why is the commented out code `// app.use(express.static('./public'));` not being used?\n- The commented out code is not being used because it is not necessary for the functionality of this specific code. It is likely that it was included for future use or as a placeholder.","metadata":{"source":".autodoc/docs/markdown/server/index.md"}}],["2",{"pageContent":"[View code on GitHub](https://github.com/LaGuerrePiece/moonolith/server/liste.txt)\n\nThe code provided is a simple text file that contains four lines of text: \"Bonjour\", \"Kikooe\", \"Arigato\", and \"TEST\". \n\nThe purpose of this code is not immediately clear, as it appears to be a simple list of words. However, in the larger context of the Moonolith project, this code could potentially be used as a data source or input for another part of the project.\n\nFor example, if the Moonolith project is a natural language processing (NLP) system, this code could be used as a sample dataset for training or testing the NLP algorithms. The words in the file could represent different languages or types of text that the NLP system needs to be able to handle.\n\nHere is an example of how this code could be used in the larger Moonolith project:\n\n```python\n# Assume the Moonolith project is an NLP system\n# Load the text file\nwith open('Moonolith/file.txt', 'r') as file:\n    lines = file.readlines()\n\n# Process the lines of text\nfor line in lines:\n    # Perform NLP operations on each line\n    # ...\n\n# Continue with the rest of the NLP system\n# ...\n```\n\nIn this example, the code reads the lines from the text file and then performs NLP operations on each line. The specific NLP operations would depend on the requirements of the Moonolith project.\n\nOverall, while the code provided may seem simple and insignificant on its own, it could potentially serve as a valuable resource or input for other parts of the Moonolith project, such as training or testing data for an NLP system.\n## Questions: \n 1. What is the purpose of this code? - The code appears to be a list of strings, but it is unclear what it is used for or how it is intended to be used.\n2. Are there any specific requirements or dependencies for this code? - It is unclear if there are any specific requirements or dependencies needed to run or use this code.\n3. Is there any additional documentation or context available for this code? - It would be helpful to know if there is any additional documentation or context available that could provide more information about the purpose and usage of this code.","metadata":{"source":".autodoc/docs/markdown/server/liste.md"}}],["3",{"pageContent":"[View code on GitHub](https://github.com/LaGuerrePiece/moonolith/src/assets/sounds.js)\n\nThe code provided is a module that handles audio playback for the Moonolith project. It includes functions for toggling mute, playing sounds, toggling music, playing music, stopping sounds, and toggling rumble. \n\nThe code begins by creating two instances of the `Audio` class, `music` and `rumble`, which are assigned to the respective audio files \"/audio/theEndOfTheWorld.mp3\" and \"/audio/rumble.mp3\". The `music` audio is set to loop continuously using the `loop` property.\n\nThe module also defines two variables, `muteState` and `lastPlayedSound`, which are used to keep track of the mute state and the last time a sound was played, respectively. Both variables are initially set to `false` and the current timestamp.\n\nThe `toggleMute` function is exported and allows the user to toggle the mute state. If `muteState` is `true`, it plays the `music` audio and sets `muteState` to `false`. Otherwise, it pauses both the `music` and `rumble` audio and sets `muteState` to `true`.\n\nThe `playSound` function is also exported and is used to play a sound. It takes two parameters, `name` and `limit`. If `muteState` is `true`, the function returns early and does not play the sound. If the difference between the current timestamp and `lastPlayedSound` is less than `limit`, the function also returns early and does not play the sound. Otherwise, it creates a new instance of the `Audio` class with the provided `name` and plays the audio. Finally, it updates `lastPlayedSound` to the current timestamp.\n\nThe `toggleMusic` function is exported and toggles the playback of the `music` audio. If the `music` audio is paused, it plays it. Otherwise, it pauses it.\n\nThe `playMusic` function is exported and simply plays the `music` audio.\n\nThe `stopSound` function is exported and stops the playback of a sound. It takes a `name` parameter, creates a new instance of the `Audio` class with the provided `name`, and pauses the audio.\n\nThe `toggleRumble` function is exported and toggles the playback of the `rumble` audio. If `muteState` is `true`, the function returns early and does not play the audio. If the `rumble` audio is paused, it plays it. Otherwise, it calls the `fadeAudio` function.\n\nThe `fadeAudio` function is a helper function that gradually reduces the volume of an audio until it reaches 0. It takes an `audio` parameter and sets an interval that runs every 200 milliseconds. Within the interval, it checks if the current time of the audio is within 5 seconds of the end and if the volume is not already 0. If so, it reduces the volume by 0.1. If the volume becomes less than 0.003, it sets the volume to 0, clears the interval, and pauses the audio.\n\nOverall, this module provides a set of functions to control audio playback in the Moonolith project, including playing sounds, music, and rumble, toggling mute, and stopping sounds.\n## Questions: \n 1. What is the purpose of the `toggleMute` function?\n- The `toggleMute` function is responsible for toggling the mute state of the audio. If the `muteState` is true, it will play the music and set `muteState` to false. Otherwise, it will pause the music and rumble and set `muteState` to true.\n\n2. What does the `playSound` function do?\n- The `playSound` function plays a sound with the given name if the `muteState` is false and if the time since the last played sound plus the limit is greater than the current time. It sets the `lastPlayedSound` to the current time after playing the sound.\n\n3. What is the purpose of the `fadeAudio` function?\n- The `fadeAudio` function gradually reduces the volume of the given sound until it reaches 0. It uses an interval to continuously check the current time of the sound and reduce the volume by 0.1 until it reaches a very low value. Once the volume is close to 0, it sets the volume to 0, clears the interval, and pauses the sound.","metadata":{"source":".autodoc/docs/markdown/src/assets/sounds.md"}}],["4",{"pageContent":"[View code on GitHub](https://github.com/LaGuerrePiece/moonolith/src/constants.js)\n\nThe code provided is a class called `Const` that exports as the default export. It contains various static properties and methods that define constants used in the larger Moonolith project.\n\nThe `Const` class has several static getter methods that return constant values. For example, the `COLUMNS` getter returns the value 370, the `MARGIN_TOP` getter returns the value 650, and so on. These constants are used to define the dimensions and layout of the Moonolith project.\n\nOne important constant is `monolithHeight`, which is initially set to 0. The `LINES` getter method uses this constant, along with other margin constants, to calculate the total number of lines in the Moonolith project. The `MONOLITH_LINES` getter method simply returns the value of `monolithHeight`.\n\nThe `setMonolithHeight` method is a static setter method that allows the `monolithHeight` constant to be updated with a new value. This method can be used to dynamically adjust the height of the Moonolith project.\n\nThe class also defines several constants for colors used in the project. These constants are defined as arrays of RGB values. For example, `RGB1` represents the color black (#000000) and `RGB16` represents a shade of blue (#2f3c99). These color constants are used throughout the project to define the color palette.\n\nThe `PALETTE` constant is an array that contains all the color constants defined in the class. The `GUI_PALETTE` constant is a modified version of the `PALETTE` constant that includes an additional default color.\n\nThe `PARALLAX_LAYERS` constant is an object that defines the parallax layers used in the Moonolith project. Each layer is represented by a key-value pair, where the key is the layer index and the value is the parallax effect strength.\n\nThe `PALETTE_INFO` constant is an object that defines different configurations for the color palette display. Each configuration is represented by a key-value pair, where the key is a string identifier and the value is an object containing various properties related to the display of the color palette.\n\nOverall, the `Const` class provides a centralized location for defining and accessing constants used in the Moonolith project. It allows for easy customization and adjustment of various aspects of the project, such as dimensions, colors, and parallax effects.\n## Questions: \n 1. What is the purpose of the `monolithHeight` variable and how is it used in the code?\n- The `monolithHeight` variable is used to determine the number of lines in the monolith. It is used in the calculation of the `LINES` and `MONOLITH_LINES` properties.\n\n2. What is the purpose of the `MARGIN_TOP`, `MARGIN_BOTTOM`, `MARGIN_LEFT`, and `MARGIN_RIGHT` properties?\n- These properties define the margins of the monolith. They are used in the calculation of the `LINES` and `MONOLITH_COLUMNS` properties.\n\n3. What is the purpose of the `PALETTE_INFO` object and how is it used in the code?\n- The `PALETTE_INFO` object contains information about different palettes. It is used to define the offset, spacing, and other properties of each palette.","metadata":{"source":".autodoc/docs/markdown/src/constants.md"}}],["5",{"pageContent":"[View code on GitHub](https://github.com/LaGuerrePiece/moonolith/src/controls/mobileControls.js)\n\nThe code provided is a module that handles touch events on a mobile device for the Moonolith project. It exports a function called `mobileEventListener` that sets up event listeners for touch events and defines the behavior for each event.\n\nThe `mobileEventListener` function uses the Hammer.js library to handle touch events on the `canvas` element. It enables the `pinch` gesture and sets up an event handler for the `pinch` event. When the `pinch` event is triggered, the function checks if the `panMode` variable is true. If it is, it adjusts the zoom level based on the scale of the pinch gesture. If the scale is greater than 1, it calls the `increaseZoom` function with a zoom increment of 0.02. If the scale is less than 1, it calls the `decreaseZoom` function with a zoom increment of 0.02.\n\nThe function also sets up event handlers for the `tap`, `touchmove`, `touchend`, and `touchstart` events. When the `tap` event is triggered, the function calls the `touchManager` function, passing the event object as an argument. The `touchManager` function handles the logic for different types of touch events.\n\nIf the `tap` event is triggered and the `FAQ` variable is truthy, the function calls the `clickManager` function with the event object as an argument. Otherwise, it checks the position of the touch event relative to various elements on the screen using the `isInSquare` and `isInCircle` functions from the `conversions` module. Depending on the position of the touch event, it performs different actions such as toggling the `panMode`, opening a URL in a new tab, or displaying the FAQ.\n\nIf the `panMode` is true, the `touchPan` function is called to handle touch events for panning. It keeps track of the previous touch coordinates and calculates the change in coordinates when the touch moves. It then calls the `changeViewPos` function to update the view position based on the change in coordinates.\n\nIf the `panMode` is false, the `touchDraw` function is called to handle touch events for drawing. It extracts the touch coordinates from the event object and checks if the touch is within the bounds of the `palette` element. If it is, it returns early. Otherwise, it calls the `startUsingTool` function to start using the selected drawing tool.\n\nThe module also exports a function called `setPanMode` that takes a boolean argument `mode`. If the `mode` is the same as the current `panMode`, the function returns early. Otherwise, it calls the `togglePanMode` function to toggle the `panMode` and update the display of certain elements in the GUI.\n\nOverall, this module provides the necessary event handling logic for touch events on a mobile device in the Moonolith project. It allows users to interact with the canvas, toggle between panning and drawing modes, and perform various actions based on the position of the touch events.\n## Questions: \n **Question 1:** What is the purpose of the `mobileEventListener` function?\n    \n**Answer:** The `mobileEventListener` function is responsible for setting up event listeners for touch and pinch gestures on a mobile device.\n\n**Question 2:** What does the `togglePanMode` function do?\n    \n**Answer:** The `togglePanMode` function toggles the `panMode` variable and updates the display of certain elements in the `GUICatalog` object.\n\n**Question 3:** What is the purpose of the `touchManager` function?\n    \n**Answer:** The `touchManager` function handles touch events and performs different actions based on the type of touch event and the position of the touch on the screen.","metadata":{"source":".autodoc/docs/markdown/src/controls/mobileControls.md"}}],["6",{"pageContent":"[View code on GitHub](https://github.com/LaGuerrePiece/moonolith/src/display/FAQ.js)\n\nThe code provided is a part of the Moonolith project and is responsible for displaying and managing the Frequently Asked Questions (FAQ) section of the project's user interface.\n\nThe code begins by importing various modules and functions from other files within the project. These include the `FAQviewPosY` variable from the `view.js` file, the `imageCatalog` object from the `images.js` file, the `GUICatalog` object from the `GUI.js` file, and the `changeViewPos` and `zoom` functions from the `view.js` file. It also imports the `setPanMode` function from the `mobileControls.js` file and the `deviceType` variable from the `controls.js` file.\n\nThe code then defines and exports several variables and objects. The `FAQ` variable is set to `false` initially and is used to keep track of whether the FAQ section is currently being displayed. The `FAQType` variable is used to store the type of FAQ being displayed. The `FAQCatalog` object contains information about different types of FAQs, such as their names, parallax values, and starting positions.\n\nThe `displayFAQ` function is responsible for displaying the FAQ section. It takes a `type` parameter, which specifies the type of FAQ to display. The function sets the `zoom` to 1, sets the `FAQ` variable to `true`, and assigns the `type` parameter to the `FAQType` variable. If the `deviceType` is 'mobile', the `setPanMode` function is called with `true` as an argument. The `FAQCatalog.FAQ.name` is updated with the `type` parameter. Finally, the `changeViewPos` function is called with 0 and 99999 as arguments, and the `GUICatalog.faqButtonOpen.display` property is set to `false`.\n\nThe `drawFAQ` function is responsible for rendering the FAQ section on the canvas. It takes a `ctx` parameter, which represents the canvas context. The function iterates over the `FAQCatalog` object and for each entry, it calculates the `y` position based on the `FAQviewPosY` and the parallax offset. It then draws the corresponding image from the `imageCatalog` using the `drawImage` method of the canvas context. If the current layer is the FAQ layer, the `drawClouds` function is called to draw additional cloud images.\n\nThe `exitFAQ` function is responsible for exiting the FAQ section. It sets the `FAQ` variable to `false`, clears the `FAQType` variable, and calls the `changeViewPos` function with 0 and 99999 as arguments.\n\nThe `drawClouds` function is a helper function used by the `drawFAQ` function to draw cloud images. It iterates over the `imageCatalog` object and for each cloud image, it calculates the `y` position based on the `FAQviewPosY` and the parallax offset. It then draws the cloud image on the canvas.\n\nOverall, this code provides the functionality to display and manage the FAQ section of the Moonolith project's user interface. It allows users to view different types of FAQs, handles the rendering of the FAQ section and cloud images, and provides functions to enter and exit the FAQ section.\n## Questions: \n **Question 1:** What is the purpose of the `FAQviewPosY` variable and where is it defined?\n- The `FAQviewPosY` variable is used to calculate the y-coordinate position of the FAQ elements. Its purpose is to create a parallax effect. The code does not show where `FAQviewPosY` is defined, so a smart developer might wonder where this variable comes from.\n\n**Question 2:** How are the images in the `imageCatalog` and `GUICatalog` objects loaded?\n- The code references the `imageCatalog` and `GUICatalog` objects to draw images on the canvas. A smart developer might want to know how these objects are populated with image data.\n\n**Question 3:** What is the purpose of the `drawClouds` function and when is it called?\n- The `drawClouds` function is called when the name of a layer in `FAQCatalog` is 'FAQ'. A smart developer might want to know what the purpose of drawing clouds is and when this function is called in the code.","metadata":{"source":".autodoc/docs/markdown/src/display/FAQ.md"}}],["7",{"pageContent":"[View code on GitHub](https://github.com/LaGuerrePiece/moonolith/src/display/GUI.js)\n\nThe code provided is a module that handles the display and management of the GUI (Graphical User Interface) elements in the Moonolith project. The module exports several functions and objects that are used to control and update the GUI.\n\nThe `paletteCatalog` object contains a list of different palettes, each represented by a key-value pair. The keys represent the name of the palette, and the values contain the file name of the palette image. Similarly, the `GUICatalog` object contains a list of different GUI elements, each represented by a key-value pair. The keys represent the name of the GUI element, and the values contain the file name of the GUI image, as well as additional properties such as type and display status.\n\nThe `displayShareScreen` function sets the `display` property of the `share` GUI element to true, indicating that the share screen should be displayed.\n\nThe `displayPalette` function is responsible for displaying the palette GUI element. It sets the `display` property of the `mobileDraw` GUI element to true if the device type is 'mobile'. It also sets the `display` property of the `palette`, `selectorA`, and `selectorB` GUI elements based on the device type and pan mode.\n\nThe `updatePalette` function updates the GUI elements related to the palette based on the current scale factor and tool. It sets the `img` property of the `palette`, `selectorA`, `selectorB`, `mobileDraw`, and `mobileMove` GUI elements to the corresponding palette images based on the scale factor and tool. It also sets the `info` property of the `palette` GUI element based on the scale factor.\n\nThe `updateGUICatalog` function updates the position of the GUI elements based on the current canvas size and other factors. It iterates over the `GUICatalog` object and updates the `x` and `y` properties of the GUI elements based on their type and other conditions.\n\nThe `loadGUI` function loads the palette and GUI images by creating new `Image` objects and setting their `src` properties to the corresponding file paths. It also sets the `loaded` property of each GUI element to true when the image is loaded.\n\nThe `drawGUI` function is responsible for drawing the GUI elements on the canvas. It iterates over the `GUICatalog` object and uses the `ctx.drawImage` method to draw the GUI elements that have their `display` property set to true and are loaded.\n\nOverall, this code module provides the functionality to display and manage the GUI elements in the Moonolith project. It allows for the dynamic updating of the GUI based on the device type, scale factor, and other conditions.\n## Questions: \n 1. What is the purpose of the `paletteCatalog` object?\n- The `paletteCatalog` object stores information about different palettes and their corresponding file names.\n\n2. What is the purpose of the `updatePalette` function?\n- The `updatePalette` function updates the images and information in the `GUICatalog` object based on the current scale factor and tool.\n\n3. What is the purpose of the `loadGUI` function?\n- The `loadGUI` function loads the images for the palettes and GUI layers from the specified file paths.","metadata":{"source":".autodoc/docs/markdown/src/display/GUI.md"}}],["8",{"pageContent":"[View code on GitHub](https://github.com/LaGuerrePiece/moonolith/src/display/animations.js)\n\nThe code provided is part of the Moonolith project and is responsible for managing and displaying animations within the project. \n\nThe `animCatalog` object is an inventory of all the animations available in the project. Each animation is represented by a key-value pair, where the key is the name of the animation and the value is an object containing various properties of the animation. These properties include the type of animation (intro, continual, onMouse, postIntro), the starting position of the animation, whether it should be displayed or not, whether it should loop or not, the layer it belongs to, and the base64 encoded image data for the animation.\n\nThe `animFrameManager` function is responsible for managing the frames of an animation. It takes an animation name as input and retrieves the corresponding animation object from the `animCatalog`. If the animation type is 'intro' and the `introState` is false, the display property of the animation is set to false. The function then checks the current frame of the animation and determines whether to advance to the next frame, restart the animation from the beginning, or stop the animation based on the loop property. The delay between frames is determined by the delay array of the animation object.\n\nThe `launchAnim` function is used to start an animation. It takes an animation name as input, sets the display property of the animation to true, and calls the `animFrameManager` function to start managing the frames of the animation.\n\nThe `updateAnimCatalog` function is responsible for updating the position of the animations based on the view position and the parallax effect. It iterates over all the animations in the `animCatalog` and calculates the new x and y positions based on the view position and the parallax offset. It also adjusts the position for specific animations ('postMonolith' and 'autourDuFeu') by subtracting the height of the monolith lines and adding margin values.\n\nThe `drawAnimations` function is responsible for drawing the animations on the canvas. It takes a canvas context and a layer number as input. It iterates over all the animations in the `animCatalog` and checks if the animation belongs to the specified layer and if it should be displayed. If both conditions are met, it calls the `drawFrame` function to draw the current frame of the animation on the canvas.\n\nThe `drawFrame` function takes a frame, animation name, and canvas context as input. It retrieves the animation object from the `animCatalog` based on the animation name and creates an image data object for the frame. It then draws the frame on the animation's canvas and finally draws the animation's canvas on the main canvas using the x and y positions of the animation.\n\nThe `loadAnims` function is responsible for initializing the animations. It iterates over all the animations in the `animCatalog` and creates a canvas element for each animation. It sets the width and height of the canvas based on the animation's dimensions. It also sets the parallax value and current frame to their initial values. If the animation type is 'continual', it calls the `launchAnim` function to start the animation. Additionally, for the 'collision' animation, it adjusts the starting y position based on the render height.\n\nOverall, this code provides a framework for managing and displaying animations in the Moonolith project. It allows for the creation and customization of various types of animations and provides functions for starting, updating, and drawing the animations on the canvas.\n## Questions: \n 1. What is the purpose of the `animCatalog` object?\n- The `animCatalog` object stores information about different animations, including their type, position, display status, and base64 image data.\n\n2. What is the role of the `animFrameManager` function?\n- The `animFrameManager` function manages the frames of an animation by updating the current frame and determining whether to continue to the next frame, loop back to the first frame, or stop the animation.\n\n3. How are the animations drawn on the canvas?\n- The `drawAnimations` function iterates through the `animCatalog` object and draws the current frame of each animation on the canvas using the `drawFrame` function.","metadata":{"source":".autodoc/docs/markdown/src/display/animations.md"}}],["9",{"pageContent":"[View code on GitHub](https://github.com/LaGuerrePiece/moonolith/src/display/displayLoop.js)\n\nThe code provided is a part of the Moonolith project and is responsible for initializing and updating the display of the game. \n\nThe `initDisplay()` function is the entry point of the code. It initializes the canvas element, loads images, GUI elements, and animations, and starts the update loop using the `requestAnimationFrame()` function. The update loop continuously updates the image, animation, and GUI catalogs, animates the monolith if the intro state is false, clears the canvas, and then draws the layers, monolith, and GUI elements on the canvas. The `update()` function is called recursively using `requestAnimationFrame()` to create a smooth animation effect.\n\nThe `drawLayer()` function is a helper function that is responsible for drawing the images and animations for a specific layer on the canvas. It is called multiple times in the `update()` function to draw different layers.\n\nThe `drawMonolith()` function is responsible for drawing the monolith on the canvas. It calculates the height of the monolith display based on the intro state and the view position. It then creates an image data object for the monolith and sets its data using the `cutMonolith()` function. Finally, it positions the monolith on the canvas and draws it using the `putImageData()` method.\n\nThe `cutMonolith()` function is a helper function that extracts a portion of the monolith data based on the monolith display height and the intro state. It calculates the start and end coordinates for the monolith data array and returns the extracted portion.\n\nThe `shake()` function is responsible for shaking the landscape images and changing the view position. It toggles the rumble sound effect, shakes the landscape images by randomly changing their shakeX property, and changes the view position by randomly changing the viewPosX and viewPosY variables. After a certain duration, it clears the shake effects and toggles the rumble sound effect again.\n\nThe `initCanvas()` function is responsible for creating and initializing the canvas element. It creates a canvas element, appends it to the document body, sets its dimensions and style, and adds a resize manager function to handle window resizing.\n\nOverall, this code is crucial for initializing and updating the display of the Moonolith game. It loads and draws images, animations, and GUI elements, animates the monolith, handles shaking effects, and manages the canvas element.\n## Questions: \n **Question 1:** What is the purpose of the `initDisplay` function?\n\n**Answer:** The `initDisplay` function initializes the display by loading images, GUI, and animations, and then continuously updates the display by calling the `update` function.\n\n**Question 2:** What does the `drawMonolith` function do?\n\n**Answer:** The `drawMonolith` function draws the monolith on the canvas based on the current view position and the monolith display height.\n\n**Question 3:** What is the purpose of the `shake` function?\n\n**Answer:** The `shake` function shakes the landscapes by randomly changing their X position and also shakes the view position. It also clears the shake effect after a certain duration.","metadata":{"source":".autodoc/docs/markdown/src/display/displayLoop.md"}}],["10",{"pageContent":"[View code on GitHub](https://github.com/LaGuerrePiece/moonolith/src/display/images.js)\n\nThe code provided is a module that manages the image catalog for the Moonolith project. It exports several functions and a variable related to the image catalog.\n\nThe `imageCatalog` variable is an object that contains various image entries. Each entry represents an image used in the project and has properties such as `startX`, `startY`, `layer`, `type`, `fileName`, and `display`. These properties define the position, layering, type, file name, and display status of each image.\n\nThe `updateImageCatalog` function is responsible for updating the positions of the images in the catalog based on the current view position and rendering height. It also handles the display of certain images based on user interactions. For example, if the user's pointer is within a certain circular area defined by coordinates and radius, specific animations are launched and the display status of certain images is toggled.\n\nThe `displayImage` function allows for the display status of a specific image to be set to true. This can be used to show or hide specific images in the catalog.\n\nThe `initClouds` function initializes the cloud images in the catalog. It generates a random number of cloud images and assigns them random positions and types. The cloud images are loaded from files and their positions are translated over time to create a moving effect.\n\nThe `loadImages` function loads the images in the catalog by creating new `Image` objects and setting their `src` properties to the corresponding file paths. It also sets additional properties such as `shakeX` and `parallax` based on the image's type and layer.\n\nThe `drawImages` function is responsible for drawing the images onto a canvas context. It iterates over the image catalog and checks if each image should be drawn based on its layer, display status, and loaded status. If all conditions are met, the image is drawn onto the canvas.\n\nThe `addSideMonolith` function adds side monolith images to the catalog based on a given monolith height. It calculates the number of side monoliths that need to be added and creates new entries in the image catalog with updated start positions.\n\nThe `translateImage` function is a helper function used to translate the position of an image over time. It takes an image object as a parameter and sets an interval to increment its `startX` property. This creates a scrolling effect for the image.\n\nOverall, this code module manages the image catalog for the Moonolith project, including loading, positioning, and displaying images. It also handles user interactions and animations related to specific images in the catalog.\n## Questions: \n 1. What is the purpose of the `updateImageCatalog` function?\n- The `updateImageCatalog` function updates the positions of the images in the `imageCatalog` object based on the current view position and other factors.\n\n2. What is the purpose of the `displayImage` function?\n- The `displayImage` function sets the `display` property of a specific image in the `imageCatalog` object to `true`, indicating that the image should be displayed.\n\n3. What is the purpose of the `initClouds` function?\n- The `initClouds` function initializes the cloud images in the `imageCatalog` object by generating random positions and other properties for each cloud image.","metadata":{"source":".autodoc/docs/markdown/src/display/images.md"}}],["11",{"pageContent":"[View code on GitHub](https://github.com/LaGuerrePiece/moonolith/src/display/pointer.js)\n\nThe code provided is a function called `addPointer` that is used to modify a `monolithData` array based on the current `tool` and `deviceType`. The `monolithData` array represents the data of a monolith, which is a display or canvas-like object in the larger Moonolith project. The purpose of this code is to add a pointer or cursor to the monolithData array, which will be used to interact with the monolith.\n\nThe function first checks if the `deviceType` is \"mobile\". If it is, the function simply returns the `monolithData` array without making any modifications. This suggests that the code is handling different behavior for mobile devices.\n\nNext, the code checks the value of the `tool` variable. Depending on the value, different modifications are made to the `monolithData` array. The `tool` variable represents the size of the pointer or cursor being used. The possible values for `tool` are \"smol\", \"medium\", \"large\", and \"giga\".\n\nFor each tool size, the code uses nested for loops to iterate over a range of values around the current position of the pointer. The `whiten` function is called for each position within the range, passing in the `monolithData` array and the coordinates of the position. The `whiten` function modifies the `monolithData` array based on the position.\n\nAfter the nested loops, the code returns the modified `monolithData` array.\n\nThe `whiten` function is a helper function that is used to modify the `monolithData` array at a specific position. It first checks if the position is within the bounds of the `renderWidth` and `renderHeight` variables. If it is not, the function returns without making any modifications.\n\nNext, the function converts the position to `monolithPos` using the `convertToMonolithPos` function. If the `monolithPos` is falsy, meaning it is not on the monolith, the function returns without making any modifications.\n\nFinally, the function calculates the index of the position in the `monolithData` array using the `monolithPos` and `Const.MONOLITH_COLUMNS`. If the value at that index in the `monolithIndexes` array is greater than 0, the function returns without making any modifications.\n\nIf all the checks pass, the function modifies the `monolithData` array at the calculated index by adding a fraction of the difference between 255 and the current value at that index. This effectively lightens the color at that position.\n\nIn summary, the `addPointer` function is used to add a pointer or cursor to the `monolithData` array based on the current `tool` and `deviceType`. The `whiten` function is used to modify the `monolithData` array at a specific position by lightening the color. This code is likely part of a larger project that involves interacting with a monolith display or canvas.\n## Questions: \n 1. What is the purpose of the `addPointer` function?\n- The `addPointer` function is used to modify the `monolithData` array based on the `tool` and `pointer` values.\n\n2. What does the `whiten` function do?\n- The `whiten` function checks if a given position on the `monolithData` array is editable and then modifies the RGB values at that position to make it whiter.\n\n3. What are the conditions for skipping the execution of the `whiten` function?\n- The `whiten` function is skipped if the position is outside the render width and height, if the position is not on the monolith, or if the position is not editable.","metadata":{"source":".autodoc/docs/markdown/src/display/pointer.md"}}],["12",{"pageContent":"[View code on GitHub](https://github.com/LaGuerrePiece/moonolith/src/display/view.js)\n\nThe code provided is a module that contains various functions and variables related to changing and managing the view position and zoom level in the Moonolith project. \n\nThe module starts by importing various dependencies and modules from other files in the project. These include constants, the main module, the intro module, utility functions, display-related modules, and image-related modules. \n\nThe module then exports several variables and functions that can be used by other parts of the project. These include `scaleFactor`, `viewPosY`, `viewPosX`, and `FAQviewPosY`, which are all variables used to store and manage the current view position and zoom level. \n\nThe `changeViewPos` function is used to change the view position based on the input X and Y values. If the `FAQ` variable is true, indicating that the Frequently Asked Questions section is being displayed, the `changeFAQViewPos` function is called instead. The `changeViewPos` function also includes logic to limit the view position within certain boundaries. \n\nThe `changeViewPosSmoothly` function is used to smoothly change the view position based on the input Y value and an inverse speed value. It uses a loop and a setTimeout function to gradually change the view position over time. \n\nThe `setInitialViewPos` function is used to set the initial view position based on certain conditions. If a `runeNumber` is provided, it retrieves the corresponding chunk and calculates the view position based on the chunk's data. If the `Opensea` variable is true, it also sets the initial zoom level based on the chunk's width and height. If no `runeNumber` is provided, it looks for a Y value in the URL and sets the view position accordingly. \n\nThe `increaseZoom`, `decreaseZoom`, and `toggleZoom` functions are used to change the zoom level. The `zoom` function is called by these functions and is responsible for actually changing the zoom level. It also includes logic to limit the zoom level within certain boundaries. \n\nOverall, this module provides functions and variables that allow for the manipulation and management of the view position and zoom level in the Moonolith project. These functions can be used in conjunction with other modules and components to create a dynamic and interactive user experience.\n## Questions: \n **Question 1:** What is the purpose of the `changeViewPos` function?\n\n**Answer:** The `changeViewPos` function is responsible for changing the view position of the canvas based on the input X and Y values. It also applies limits to the view position to ensure it stays within the boundaries of the canvas.\n\n**Question 2:** What is the purpose of the `setInitialViewPos` function?\n\n**Answer:** The `setInitialViewPos` function is used to set the initial view position of the canvas. It first checks if a `runeNumber` is provided, and if so, it retrieves the corresponding chunk and calculates the view position based on the chunk's data. If no `runeNumber` is provided, it looks for a Y value in the URL and sets the view position accordingly.\n\n**Question 3:** What is the purpose of the `zoom` function?\n\n**Answer:** The `zoom` function is responsible for zooming in or out of the canvas. It takes a factor as input and adjusts the scale of the canvas accordingly. It also updates the view position and palette based on the zoom factor.","metadata":{"source":".autodoc/docs/markdown/src/display/view.md"}}],["13",{"pageContent":"[View code on GitHub](https://github.com/LaGuerrePiece/moonolith/src/intro.js)\n\nThe code provided is a module that is part of the Moonolith project. It imports various functions and variables from other modules and exports some variables and functions as well. \n\nThe purpose of this code is to handle the launch of the Moonolith project's introduction. The `launchIntro` function is the main function that is called to initiate the introduction. It sets the `introState` variable to true, sets the height of the monolith display, changes the view position, initializes the display, imports chunks, and launches animations. It then waits for a certain delay and checks if the `introState` is still true before continuing with the next set of actions. This process continues until the final part of the introduction is reached.\n\nThe `skipIntro` function is used to skip the introduction. It checks if the `introState` is true and if not, it returns. Otherwise, it hides certain images and animations, unlocks controls, and displays the panneau and palette.\n\nThe `monolithGoUpDuringIntro` function is called during the introduction to gradually increase the height of the monolith display. It uses a loop to increment the `monolithDisplayHeightIntro` variable and sets a timeout based on a scaling value.\n\nThe `displayPanneau` function is used to display the panneau image. It first checks if the device type is mobile and if so, it returns. Otherwise, it determines the language of the browser and sets the source of the panneau image accordingly. It then launches the panneau rainbow animation and displays the panneau decor image.\n\nOverall, this code is responsible for handling the launch and skipping of the Moonolith project's introduction, as well as managing the display of certain images and animations during the introduction. It is an important part of the larger project as it sets the initial state and prepares the user for the main experience of the Moonolith project.\n## Questions: \n 1. What is the purpose of the `launchIntro` function?\n- The `launchIntro` function is responsible for executing a series of animations and actions to display the intro of the Moonolith project.\n\n2. What is the significance of the `introState` variable?\n- The `introState` variable is used to keep track of whether the intro is currently being displayed or not. It is used to control the flow of the code and determine when to return or continue with certain actions.\n\n3. What does the `monolithGoUpDuringIntro` function do?\n- The `monolithGoUpDuringIntro` function is responsible for incrementing the `monolithDisplayHeightIntro` variable and shaking the monolith during the intro. It is called in a loop to gradually increase the height of the monolith.","metadata":{"source":".autodoc/docs/markdown/src/intro.md"}}],["14",{"pageContent":"[View code on GitHub](https://github.com/LaGuerrePiece/moonolith/src/main.js)\n\nThe code provided is a part of the Moonolith project and is responsible for initializing the application and importing chunks of data into the Monolith.\n\nThe `initApp` function is the entry point of the application. It first calls the `setRoute` function to set the route based on the URL parameters. It checks if the `Opensea` parameter is present in the URL, and if so, assigns it to the `Opensea` variable. It also parses the `runeNumber` from the URL and assigns it to the `runeNumber` variable. If the `Opensea` parameter is not present, it checks if the user has visited the site before by checking the `visited` cookie. If the user has not visited before, it sets the `firstTime` variable to true and sets the `visited` cookie to true for 7 days.\n\nNext, the function calls the `parseAPNG` function to parse APNG images. If it is the first time and the `Opensea` variable is not set, it launches the intro. Otherwise, it sets the monolith height, initializes the display, imports the chunks, and skips the intro.\n\nThe `setInterval` function is used to periodically call the `importNewChunks` function every 30 seconds. This function checks if new chunks have been imported by comparing the `importedChunks` variable with the number of chunks in the metadata. If new chunks are found, it retrieves the chunks and buffers them on the Monolith.\n\nThe `chunkImport` function is responsible for importing the chunks. It first waits for the `monoHeightSet` promise to resolve, which is set in the `setMonoHeightAndBuildIt` function. Then, it retrieves all the chunks using the `getAllChunks` function and buffers each chunk on the Monolith.\n\nThe `importNewChunks` function is called periodically to import new chunks. It retrieves the metadata and compares the number of imported chunks with the number of chunks in the metadata. If new chunks are found, it retrieves each chunk and buffers it on the Monolith. It also updates the Monolith height based on the number of imported chunks.\n\nThe `setMonoHeightAndBuildIt` function retrieves the metadata and calculates the Monolith height based on the number of Klon and the threshold in the metadata. It sets the Monolith height using the `setMonolithHeight` function from the `Const` module, builds the Monolith, and initializes the clouds.\n\nOverall, this code initializes the application, sets the route, imports and buffers chunks on the Monolith, and periodically imports new chunks. It also handles the Monolith height and initializes the display.\n## Questions: \n 1. What is the purpose of the `initApp` function and how is it used?\n- The `initApp` function is responsible for initializing the application. It sets the route, parses APNG files, launches the intro if it's the first time, and imports chunks. It is called once at the start of the program.\n\n2. What is the purpose of the `chunkImport` function and how is it used?\n- The `chunkImport` function is used to import chunks and buffer them on the monolith. It takes a `monoHeightSet` parameter and imports all chunks using the `getAllChunks` function. It is called within the `initApp` function.\n\n3. What is the purpose of the `importNewChunks` function and how is it used?\n- The `importNewChunks` function is used to import new chunks and buffer them on the monolith. It checks if there are any new chunks available by comparing the `importedChunks` variable with the number of chunks in the metadata. If there are new chunks, it retrieves and buffers them. It is called periodically using `setInterval`.","metadata":{"source":".autodoc/docs/markdown/src/main.md"}}],["15",{"pageContent":"[View code on GitHub](https://github.com/LaGuerrePiece/moonolith/src/monolith/monolith.js)\n\nThe code provided is a part of the Moonolith project and is responsible for building and manipulating a monolith. The monolith is represented as a two-dimensional array of pixels, where each pixel has a position, color, and zIndex. The code provides functions for building the monolith, drawing pixels, getting the color of a pixel, erasing all pixels, and increasing the height of the monolith.\n\nThe `buildMonolith` function initializes the monolith array with default colors for each pixel. It creates a Uint8ClampedArray with a size of `Const.MONOLITH_LINES * Const.MONOLITH_COLUMNS * 4`, where each pixel is represented by four values (RGBA). The function then sets the initial color values for each pixel in the monolith array.\n\nThe `drawPixel` function is responsible for drawing a pixel at a given position with a specified zIndex and color. It first checks if the position is within the bounds of the monolith. If it is not, the function returns. It then checks if the pixel at the given position is editable based on its current zIndex. If it is not editable, the function returns. Next, it checks if the new pixel has the same position, zIndex, and color as the existing pixel. If they are the same, the function returns. If the pixel is currently being animated, the function returns. If the pixel is being drawn by the user (zIndex = 0), it adds the current pixel color to the undo stack. \n\nThe function then determines the transition type based on the zIndex. If the zIndex is 0, the transition type is 'draw'. If the zIndex is undefined, the transition type is 'erase'. If the zIndex corresponds to a chunk of animated pixels, the transition type is 'import'. If the transition type is 'draw' or 'erase', the function sets the pixel in the animatedPixels map with the transition type, color, and duration. If the transition type is 'import', it adds the pixel position and color to the data array of the corresponding chunk in the chunksToAnimateInfo map. If the transition type is undefined, it sets the color of the pixel directly in the monolith array.\n\nThe function then updates the zIndex of the pixel in the monolithIndexes array. If the zIndex is 0, it plays a sound effect. If the zIndex is undefined, it plays a different sound effect.\n\nThe `getColor` function returns the color of a pixel at a given position in the monolith array.\n\nThe `eraseAllPixel` function iterates over all pixels in the monolith and calls the `drawPixel` function to erase each pixel by setting its color to the default color. It then closes the current event and plays a sound effect.\n\nThe `increaseMonolithHeight` function increases the height of the monolith by a specified number of rows. It creates a new Uint8ClampedArray with a larger size to accommodate the additional rows. It copies the existing monolith array into the new array and sets the default color values for the new rows. It then updates the monolith and monolithIndexes variables with the new array and adds undefined values for the zIndex of the new rows in the monolithIndexes array.\n\nThe function then schedules a series of timeouts to gradually increase the height of the monolith. It uses a logarithmic scaling value to control the delay between each increase in height. After the specified delay, it calls a function to update the height of the monolith.\n\nFinally, the function calls the `shake` function to animate the monolith.\n\nOverall, this code provides the functionality to build, draw, erase, and manipulate a monolith in the Moonolith project. It is an essential component of the larger project, allowing users to interact with and modify the monolith.\n## Questions: \n 1. **What is the purpose of the `buildMonolith` function?**\nThe `buildMonolith` function initializes the `monolith` and `monolithIndexes` arrays with default values based on the constants defined in the `Const` module.\n\n2. **What is the significance of the `zIndex` parameter in the `drawPixel` function?**\nThe `zIndex` parameter determines the layering of the pixel being drawn. A lower `zIndex` value means the pixel will be drawn on top of pixels with higher `zIndex` values.\n\n3. **What is the purpose of the `increaseMonolithHeight` function?**\nThe `increaseMonolithHeight` function increases the height of the `monolith` and `monolithIndexes` arrays by adding new rows. It also triggers a visual effect and animation to simulate the growth of the monolith.","metadata":{"source":".autodoc/docs/markdown/src/monolith/monolith.md"}}],["16",{"pageContent":"[View code on GitHub](https://github.com/LaGuerrePiece/moonolith/src/monolith/monolithAnims.js)\n\nThe code provided is a part of the Moonolith project and is responsible for animating the monolith display. The monolith display is a grid of pixels represented by the `monolith` array. The purpose of this code is to animate different transitions and effects on the monolith display.\n\nThe code begins by importing necessary constants and modules from other files in the project. It also exports some variables and functions to be used in other parts of the project.\n\nThe `animateMonolith` function is the main function that triggers the animation of the monolith. It iterates over the `chunksToAnimateInfo` object, which contains information about the chunks of the monolith that need to be animated. For each chunk, it checks if it is currently visible on the screen and calls the `animateRune` function to animate the chunk.\n\nThe `animateRune` function is responsible for animating a specific chunk of the monolith. It first checks if the chunk has already been animated before. If not, it retrieves the rune data for the chunk from the `chunksToAnimateInfo` object. It then iterates over the rune data and adds the pixels to the `animatedPixels` map with the transition type set to 'import'. This triggers the animation of the pixels with the specified color.\n\nAfter a delay of 1600 milliseconds, the function proceeds to animate the white color on the rune. It iterates over the pixels within the rune's boundaries and adds them to the `animatedPixels` map with the transition type set to 'whiteOnRune'. The counter value determines the speed of the animation.\n\nNext, the function animates the rune contour by iterating over the pixels within the rune's boundaries and adding the neighboring pixels to the `animatedPixels` map with the transition type set to 'runeContour'. This creates a contour effect around the rune.\n\nThe `draw` function is a helper function that updates the color of a pixel in the `monolith` array.\n\nThe `endTransition` function is a helper function that ends the transition of a pixel by updating its color in the `monolith` array and removing it from the `animatedPixels` map.\n\nThe `avg` function is a helper function that calculates the average color between two colors.\n\nOverall, this code is responsible for animating different transitions and effects on the monolith display. It is used in the larger Moonolith project to create dynamic and visually appealing animations on the monolith.\n## Questions: \n 1. What is the purpose of the `animateMonolith` function?\n- The `animateMonolith` function triggers different animations on the `monolith` based on the values in the `animatedPixels` map.\n\n2. What is the purpose of the `animateRune` function?\n- The `animateRune` function is called to animate a specific rune on the `monolith`. It sets up different animations for the rune, such as displaying the rune, adding a white overlay, and drawing the rune's contour.\n\n3. What is the purpose of the `endTransition` function?\n- The `endTransition` function is called to finalize an animation transition on a specific pixel. It sets the pixel's color to the final color and removes it from the `animatedPixels` map.","metadata":{"source":".autodoc/docs/markdown/src/monolith/monolithAnims.md"}}],["17",{"pageContent":"[View code on GitHub](https://github.com/LaGuerrePiece/moonolith/src/monolith/tools.js)\n\nThe code provided is a module that contains various functions and variables related to a drawing tool in the Moonolith project. The purpose of this code is to handle user interactions with the drawing tool, such as selecting the brush size, picking colors, and drawing pixels on a canvas.\n\nThe code begins by importing various dependencies and constants from other files in the project. It then initializes some variables, including the current tool (defaulting to 'smol'), the colors picked by the user, and the color numbers associated with those colors.\n\nThe `startUsingTool` function is the main entry point for using the drawing tool. It takes in a mouse event and the current mouse position. If the middle mouse button is pressed, it calls the `colorPicker` function to pick a color based on the mouse position. Otherwise, it sets the `button` variable to the button that was pressed and calls the `useTool` function. It also sets up event listeners for mouse movement and mouse release.\n\nThe `useTool` function is responsible for actually drawing pixels on the canvas based on the current tool, color, and mouse position. It first determines the color and zIndex (used for layering) based on the current button and color picked. It then converts the mouse position to the appropriate format and checks if it is valid. Depending on the current tool, it uses nested loops to draw pixels in different patterns on the canvas.\n\nThe `brushSwitch` function is called when the user wants to switch between different brush sizes. It plays a sound effect and updates the current tool accordingly.\n\nThe `selectBrush` function is called when the user wants to directly select a specific brush size. It updates the current tool accordingly.\n\nThe `colorPicker` function is called when the user wants to pick a color from the canvas. It retrieves the color at the specified mouse position and compares it to the available colors in the palette. If a match is found, it calls the `colorSwitch` function to update the picked colors.\n\nThe `colorSwitch` function is called when the user wants to switch between the two picked colors. It updates the color numbers and picked colors based on the button pressed and the selected color.\n\nOverall, this code provides the functionality for the drawing tool in the Moonolith project. It allows users to select different brush sizes, pick colors, and draw pixels on a canvas. The code can be used in conjunction with other modules and components to create a complete drawing application.\n## Questions: \n 1. What does the `startUsingTool` function do and how is it triggered?\n- The `startUsingTool` function is triggered by a mouse event. It checks if the mouse button is the middle button and if so, it calls the `colorPicker` function. Otherwise, it sets the `button` variable to the value of the mouse button and calls the `useTool` function. It also sets up event listeners for mouse movement and mouse release.\n\n2. What does the `useTool` function do and how does it determine the color and zIndex?\n- The `useTool` function is called when the mouse is moved while a tool is being used. It determines the color to be used based on the value of the `button` variable (0 for `colorPicked1` and any other value for `colorPicked2`). The zIndex is determined based on whether the color is the default color or not.\n\n3. What does the `brushSwitch` function do and how does it update the tool?\n- The `brushSwitch` function is called when the brush switch button is clicked. It plays a sound and updates the tool based on its current value. If the current tool is 'smol', it changes it to 'medium'. If the current tool is 'medium', it changes it to 'large'. If the current tool is 'large' or 'giga', it changes it back to 'smol'. It also calls the `updatePalette` function.","metadata":{"source":".autodoc/docs/markdown/src/monolith/tools.md"}}],["18",{"pageContent":"[View code on GitHub](https://github.com/LaGuerrePiece/moonolith/src/monolith/undoStack.js)\n\nThe code provided is a module that handles the management of events and changes in a larger project called Moonolith. The purpose of this code is to keep track of changes made to a monolith, which is represented by the `monolith` and `monolithIndexes` arrays. \n\nThe code starts by importing the `Const` module from the '../constants' file and the `monolith` and `monolithIndexes` arrays from the './monolith' file.\n\nThe code then initializes several variables:\n- `eventStack` and `inverseEventStack` are arrays that will store the events and their inverse events respectively.\n- `currentEvent` and `inverseCurrentEvent` are arrays that will store the changes made in the current event and its inverse event respectively.\n- `maxSize` is a constant that determines the maximum size of the event stacks.\n\nThe code then defines several functions:\n- `closeCurrentEvent` is a function that is called when an event is completed. It pushes the current event to the `eventStack`, removes the oldest event from the stack if it exceeds the `maxSize`, and resets the `currentEvent` and `inverseEventStack` arrays.\n- `addToCurrentEvent` is a function that is called when a change is made to the monolith. It adds the change to the `currentEvent` array.\n- `undo` is a function that is called when the user wants to undo the last event. It pops the last event from the `eventStack`, applies the inverse changes to the monolith, and pushes the inverse changes to the `inverseEventStack`. It also removes the oldest inverse event from the stack if it exceeds the `maxSize`.\n- `redo` is a function that is called when the user wants to redo the last undone event. It pops the last inverse event from the `inverseEventStack`, applies the changes to the monolith, and pushes the changes to the `eventStack`. It also removes the oldest event from the stack if it exceeds the `maxSize`.\n\nFinally, the code exports the `closeCurrentEvent`, `addToCurrentEvent`, `undo`, and `redo` functions for use in other parts of the Moonolith project.\n\nIn the larger Moonolith project, this code can be used to keep track of changes made to the monolith and allow the user to undo and redo those changes. For example, if the user paints a pixel on the monolith and then decides to undo that change, the `undo` function can be called to revert the pixel to its previous state. Similarly, if the user undoes a change and then decides to redo it, the `redo` function can be called to reapply the change. This functionality can be useful in applications where the user needs to have fine-grained control over the changes made to a visual representation, such as an image editor or a drawing application.\n## Questions: \n 1. What is the purpose of the `eventStack` and `inverseEventStack` arrays?\n- The `eventStack` array stores arrays of changes made to the `monolith` object, while the `inverseEventStack` array stores arrays of changes made during undo operations.\n\n2. What is the significance of the `maxSize` constant?\n- The `maxSize` constant determines the maximum number of events that can be stored in the `eventStack` and `inverseEventStack` arrays. If the arrays exceed this size, the oldest events will be removed.\n\n3. How are changes to the `monolith` object and `monolithIndexes` array being undone and redone?\n- Changes are undone by popping an event array from the `eventStack`, reverting the changes made in that event, and pushing the inverse changes to the `inverseEventStack`. Redoing changes is done by popping an event array from the `inverseEventStack`, reverting the inverse changes made in that event, and pushing the changes back to the `eventStack`.","metadata":{"source":".autodoc/docs/markdown/src/monolith/undoStack.md"}}],["19",{"pageContent":"[View code on GitHub](https://github.com/LaGuerrePiece/moonolith/src/utils/conversions.js)\n\nThe code provided is a collection of utility functions that are used in the Moonolith project. These functions are responsible for handling mouse events and converting mouse coordinates to positions within the Moonolith grid.\n\nThe `isInCircle` function takes in the mouse position, the center coordinates of a circle, its radius, and the current plan and catalog. It first converts the mouse position to the corresponding layer using the `convertToLayer` function. Then, it calculates the distance between the mouse position and the center of the circle using the distance formula. If the distance is less than or equal to the radius, it returns true, indicating that the mouse is inside the circle.\n\nThe `isInSquare` function is similar to `isInCircle`, but it checks if the mouse position is inside a square defined by its minimum and maximum x and y coordinates. It also uses the `convertToLayer` function to convert the mouse position to the corresponding layer.\n\nThe `convertToLayer` function takes in the mouse coordinates, the current plan, and the catalog. It determines the appropriate catalog based on the provided catalog parameter and assigns it to `thisCatalog`. Then, it retrieves the image associated with the current plan from the catalog. Finally, it subtracts the image's x and y coordinates from the mouse coordinates to obtain the coordinates within the layer.\n\nThe `mousePosInGrid` function is responsible for converting the mouse position relative to the canvas to the corresponding position within the Moonolith grid. It takes in the mouse event object and calculates the x and y coordinates by subtracting the canvas's bounding client rectangle's x and y coordinates from the mouse event's x and y coordinates, respectively. It then divides these values by the product of the scaleFactor, pixelSize, and converts them to integers using `Math.floor`.\n\nThe `convertToMonolithPos` function converts the mouse position to the corresponding position within the Moonolith grid. It takes in the mouse position and adjusts the y coordinate by subtracting the viewPosY, renderHeight, and other constants. It also adjusts the x coordinate by subtracting the viewPosX and other constants. If the resulting x and y coordinates are outside the bounds of the Moonolith grid, it returns undefined. Otherwise, it returns the adjusted mouse position.\n\nThese utility functions are likely used throughout the Moonolith project to handle mouse events and convert mouse coordinates to positions within the Moonolith grid. They provide a convenient way to check if the mouse is inside specific shapes and convert mouse positions to the appropriate coordinates within the project.\n## Questions: \n **Question 1:** What is the purpose of the `isInCircle` function?\n\n**Answer:** The `isInCircle` function checks if a given mouse position is inside a circle defined by its center coordinates, radius, and other parameters.\n\n**Question 2:** What does the `convertToLayer` function do?\n\n**Answer:** The `convertToLayer` function takes a set of coordinates and converts them to a new set of coordinates relative to a specific image or GUI element.\n\n**Question 3:** What is the purpose of the `convertToMonolithPos` function?\n\n**Answer:** The `convertToMonolithPos` function converts a given mouse position to a position within the Monolith grid, taking into account various constants and offsets.","metadata":{"source":".autodoc/docs/markdown/src/utils/conversions.md"}}],["20",{"pageContent":"[View code on GitHub](https://github.com/LaGuerrePiece/moonolith/src/utils/imageManager.js)\n\nThe code provided is a module that is part of the Moonolith project. It contains various functions and imports necessary for handling image animations and manipulating image data.\n\nThe code begins by importing several modules and dependencies, including `UPNG` from the `upmc` module, `runeNumber` from the `main` module, `Const` from the `constants` module, and various functions and variables from other modules within the `monolith` and `display` directories.\n\nThe `saveToEthernity` function is defined, which checks if the Metamask browser extension is present. If it is, the function converts the monolith image data to base64 format and passes it to the `chunkCreator` function. If Metamask is not present, the `displayFAQ` function is called to display a message to the user.\n\nThe `parseAPNG` function is defined, which imports multiple layers of animation by iterating over the `animCatalog` object and calling the `decodeAndFormatAnimation` function for each animation.\n\nThe `parsePNG` function is defined, which decodes a PNG image from base64 format to a buffer using the `ApngToBuffer` function.\n\nThe `decodeAndFormatAnimation` function is defined, which takes an index as input and retrieves the corresponding animation data from the `animCatalog` object. It decodes the animation from base64 format to a buffer using the `ApngToBuffer` function and assigns the decoded frames, delay times, width, and height to the animation object.\n\nThe `ApngToBuffer` function is defined, which takes a buffer as input and decodes it using the `UPNG.decode` function. It then converts the decoded buffer to RGBA8 format using the `UPNG.toRGBA8` function and extracts the frames, delay times, width, and height from the decoded buffer. The function returns an object containing the decoded frames and other information.\n\nThe `pngToBufferToRGBA8` function is defined, which takes a buffer as input and performs the same decoding and conversion steps as the `ApngToBuffer` function, but only returns the RGBA8 buffer.\n\nThe `pngToBufferToRGB` function is defined, which takes a buffer as input and performs the same decoding step as the `ApngToBuffer` function, but only returns the RGB buffer.\n\nThe `getWidthAndHeight` function is defined, which takes data as input and decompresses it using the `decompressFromUint8Array` function from the `lz-string` module. It then converts the decompressed data to a buffer using the `ethers.utils.arrayify` function and extracts the width and height information from the buffer.\n\nThe `bufferOnMonolith` function is defined, which takes data as input and performs various operations to draw pixels on the monolith. It first converts the base64 data to a buffer using the `base64ToBuffer` function. It then extracts the width and height information from the buffer and decodes the pixel array using the `decode4bitsArray` function. The function stores the chunk data in the `chunkStock` object and, if the chunk is eligible for animation, adds it to the `chunksToAnimateInfo` object. Finally, the function iterates over the pixel array and calls the `drawPixel` function to draw pixels on the monolith.\n\nThe `monolithToBase64` function is defined, which converts the monolith image data to base64 format. It retrieves the necessary data from the `gridToArray` function and constructs an object containing the position, ymax, number of pixels, and compressed image URI. The function returns this object.\n\nThe `bufferToBase64` function is defined, which takes a buffer as input and converts it to a base64 string.\n\nThe `saveLocally` function is defined, which takes a base64 string as input and creates a hidden link element with the base64 data as the href attribute. It then triggers a click event on the link element to initiate the download of the image.\n\nThe `base64ToBuffer` function is defined, which takes a base64 string as input and converts it to a buffer.\n\nThe `gridToArray` function is defined, which retrieves the high and low coordinates of the monolith image from the `getHighLow` function. It then iterates over the image grid and constructs an array of pixels, counting the number of pixels in the process. The function also creates a 24-bit pixel array for color saving purposes. The pixel array is then converted to a paletted format using the `rgbaToColorArray` function and encoded with 4 bits per color using the `encode4bitsArray` function. The function returns an object containing the high and low coordinates, number of pixels, paletted and 24-bit pixel arrays.\n\nThe `getHighLow` function is defined, which iterates over the monolith image grid and determines the highest and lowest coordinates of non-zero pixels. It calculates the width and height of the image based on these coordinates and returns an object containing the high and low coordinates, width, and height.\n\nThe `rgbaToColorArray` function is defined, which takes an array of RGBA values as input and converts it to an array of color indices based on the `PALETTE` constant.\n\nThe `addUintTo4bitArray` function is defined, which takes an array and a uint as input and adds the uint to the array, taking care of 4-bit encoding.\n\nThe `encode4bitsArray` function is defined, which takes an array of color indices as input and encodes it with 4 bits per color.\n\nThe `decode4bitsArray` function is defined, which takes an array of encoded color indices as input and decodes it to the original array of color indices.\n\nThe `importImage` function is defined, which creates an input element of type \"file\" and triggers a file selection event. When a file is selected, the function reads the file as an array buffer and converts it to base64 format. It then calls the `bufferOn\n## Questions: \n 1. **What does the `parseAPNG` function do?**\nThe `parseAPNG` function imports multiple layers of animation by decoding and formatting each animation using the `decodeAndFormatAnimation` function.\n\n2. **What is the purpose of the `ApngToBuffer` function?**\nThe `ApngToBuffer` function takes a buffer as input, decodes it using the UPNG library, and returns an object containing the decoded frames, delays, height, and width of the animation.\n\n3. **What is the purpose of the `bufferOnMonolith` function?**\nThe `bufferOnMonolith` function takes a data object as input and draws pixels on the monolith based on the provided coordinates and pixel data. It also stores the chunk data for use in animations and checks if the chunk should be animated.","metadata":{"source":".autodoc/docs/markdown/src/utils/imageManager.md"}}],["21",{"pageContent":"[View code on GitHub](https://github.com/LaGuerrePiece/moonolith/src/utils/web3.js)\n\nThe code provided is a JavaScript file that is part of the Moonolith project. It imports various modules and defines several functions and variables.\n\nThe purpose of this code is to interact with an Ethereum smart contract deployed on the Ethereum mainnet or Rinkeby testnet. The code allows users to create and retrieve chunks of data from the smart contract, as well as perform other actions related to the Moonolith project.\n\nThe code begins by importing the necessary modules, including the ethers library for interacting with Ethereum, the contract ABI (Application Binary Interface) from a JSON file, and various other modules related to the Moonolith project.\n\nNext, the code creates an instance of the InfuraProvider from ethers, which is used to connect to the Ethereum network. The provider is initialized with the 'mainnet' network by default, but there is also a commented out line that initializes it with the 'rinkeby' network.\n\nThe code then creates an instance of the contract's interface using the contract ABI. The contract address is defined as a constant variable, which points to the Ethereum contract on the specified network.\n\nThere are also variables defined for a metamaskProvider and metamaskContract, which are used when the user is using the MetaMask browser extension to interact with the Ethereum network.\n\nThe code checks if the window.ethereum object is available, indicating that the user has MetaMask installed. If MetaMask is available, an event listener is added for the 'chainChanged' event, which triggers a function to handle changes in the Ethereum network.\n\nThe code then creates a Web3Provider instance using the MetaMask provider and checks the current network. If the network is not the mainnet, a request is made to switch to the mainnet.\n\nThe code exports several functions that can be used by other parts of the Moonolith project. These functions include chunkCreator, getChunk, getAllChunks, getChunksFromPosition, getPrice, getMetaData, openLink, getBrowserLocales, and isMetamaskHere.\n\nThe chunkCreator function is an asynchronous function that creates a new chunk by calling a function on the smart contract. It first checks the current network and requests access to the user's MetaMask accounts. It then calculates the value to send with the transaction based on the number of pixels and the current price per pixel. It creates a transaction object and waits for it to be mined. After the transaction is mined, it imports the chunk, retrieves metadata, and performs some UI-related actions.\n\nThe getChunk function retrieves data for a specific chunk from the smart contract. It takes an ID as a parameter and returns the position, ymax, number of pixels, and image string for the chunk.\n\nThe getAllChunks function retrieves data for all chunks from the smart contract. It returns an array of objects, where each object contains the position, ymax, number of pixels, and image string for a chunk.\n\nThe getChunksFromPosition function retrieves data for chunks within a specified position range from the smart contract. It takes a minimum and maximum position as parameters and returns an array of objects, where each object contains the position, ymax, number of pixels, and image string for a chunk within the specified range.\n\nThe getPrice function retrieves the current price per pixel from the smart contract.\n\nThe getMetaData function retrieves metadata about the Moonolith project from the smart contract. It returns an object containing the number of klons, the threshold, and the number of chunks.\n\nThe openLink function opens a link in a new tab based on the specified type. It can open a link to the Moonolith project on OpenSea or a link to share the user's mark on Twitter.\n\nThe getBrowserLocales function retrieves the locales (languages) supported by the user's browser. It returns an array of locale strings.\n\nThe isMetamaskHere function checks if the MetaMask browser extension is installed and returns a boolean value.\n\nThe handleChainChanged function is a callback function that is triggered when the Ethereum network changes. It recommends reloading the page to handle the network change.\n\nThe checkChain function checks the current network using the MetaMask provider and switches to the mainnet if the current network is not the mainnet.\n\nOverall, this code provides a set of functions for interacting with an Ethereum smart contract in the Moonolith project. It allows users to create and retrieve chunks of data, retrieve metadata, and perform other actions related to the project.\n## Questions: \n 1. What is the purpose of the `chunkCreator` function?\n- The `chunkCreator` function is responsible for creating a chunk by calling a method on the smart contract and handling the transaction.\n\n2. What does the `getChunk` function return?\n- The `getChunk` function returns the position, ymax, nbPix, and image string of a specific chunk.\n\n3. What is the purpose of the `checkChain` function?\n- The `checkChain` function checks if the current Ethereum network is the mainnet (chainId 1) and prompts the user to switch networks if it is not.","metadata":{"source":".autodoc/docs/markdown/src/utils/web3.md"}}],["22",{"pageContent":"[View code on GitHub](https://github.com/LaGuerrePiece/moonolith/vite.config.js)\n\nThe code provided is a configuration file for the Vite build tool, which is used in the Moonolith project. Vite is a fast build tool that is specifically designed for modern web development. This configuration file is responsible for defining the configuration options for Vite.\n\nThe code begins by importing two functions, `fileURLToPath` and `URL`, from the 'url' module. These functions are used to convert a file URL to a file path. This is necessary because the `defineConfig` function later on requires a file path as an argument.\n\nNext, the code imports the `defineConfig` function from the 'vite' module. This function is used to define the configuration options for Vite.\n\nThe `export default` statement exports a configuration object that is passed as an argument to the `defineConfig` function. This configuration object specifies various options for Vite.\n\nThe `server` option is used to configure the development server. In this case, the `hmr` (Hot Module Replacement) option is set to `false`, which disables the hot module replacement feature. Hot module replacement allows for the replacement of modules without a full page reload during development. By setting it to `false`, the code is disabling this feature.\n\nThe `resolve` option is used to configure module resolution. In this case, the `alias` option is used to define an alias for the `@` symbol. The alias is set to the file path of the 'src' directory relative to the current file. This allows for easier importing of modules from the 'src' directory by using the `@` symbol as a shorthand.\n\nOverall, this configuration file sets up the Vite build tool for the Moonolith project. It disables the hot module replacement feature and defines an alias for the 'src' directory. This configuration file is used in the larger project to ensure that Vite is properly configured and to provide a convenient way to import modules from the 'src' directory.\n## Questions: \n 1. What is the purpose of the `defineConfig` function?\n- The `defineConfig` function is used to define the configuration options for the Vite project.\n\n2. What does the `hmr: false` option in the `server` configuration do?\n- The `hmr: false` option disables hot module replacement (HMR), which means that changes to the code will not be automatically reflected in the browser without a manual refresh.\n\n3. What is the purpose of the `alias` configuration in the `resolve` object?\n- The `alias` configuration allows for the creation of custom import shortcuts, in this case, the `@` alias is used to refer to the `src` directory.","metadata":{"source":".autodoc/docs/markdown/vite.config.md"}}]]