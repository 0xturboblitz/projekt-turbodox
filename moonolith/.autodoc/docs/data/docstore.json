[["0",{"pageContent":"[View code on GitHub](https://github.com/LaGuerrePiece/moonolith/blob/master/contracts/Base64.sol)\n\nThe `Base64` library in the Moonolith project provides a function for encoding bytes in base64. Base64 encoding is a common method for converting binary data into a string format that can be easily transmitted over systems that are designed to handle text. This encoding helps to ensure that the data remains intact without modification during transport.\n\nThe library contains a single function `encode(bytes memory data)`. This function takes a byte array as input and returns a base64 encoded string. If the input data is empty, it returns an empty string.\n\nThe function first calculates the length of the encoded string, then creates a new string with the calculated length plus an extra buffer. It uses inline assembly for efficient encoding. It reads the input data three bytes at a time, and for each three bytes, it writes four base64 characters to the result string. \n\nThe assembly code also handles padding at the end of the encoded string. If the length of the input data is not a multiple of 3, it adds one or two '=' characters to the end of the encoded string to make the length a multiple of 4, as required by the base64 specification.\n\nHere is an example of how to use the `encode` function:\n\n```solidity\nbytes memory data = \"Hello, World!\";\nstring memory encoded = Base64.encode(data);\n```\n\nIn this example, `encoded` will be the base64 encoded string of \"Hello, World!\".","metadata":{"source":".autodoc/docs/markdown/contracts/Base64.md"}}],["1",{"pageContent":"[View code on GitHub](https://github.com/LaGuerrePiece/moonolith/blob/master/contracts/Context.sol)\n\nThe provided code is written in Solidity, a programming language used for implementing smart contracts on various blockchain platforms, most notably, Ethereum. This specific code defines an abstract contract named `Context`. \n\nThe `Context` contract provides information about the current execution context. This includes the sender of the transaction and its data. The contract contains two internal functions: `_msgSender()` and `_msgData()`. \n\nThe `_msgSender()` function returns the address of the entity (account or contract) that triggered the current function execution. This is typically accessed via `msg.sender` in Solidity, but this function provides a layer of abstraction to prevent direct access.\n\nThe `_msgData()` function returns the complete calldata, which is a non-modifiable, non-persistent area where function arguments are stored, and can be used within the function. This is typically accessed via `msg.data` in Solidity, but again, this function provides a layer of abstraction.\n\nThese functions are particularly useful when dealing with meta-transactions, where the account sending and paying for execution may not be the actual sender. By using these functions, the contract ensures a consistent interface for accessing this information, regardless of the underlying transaction details.\n\nHere's an example of how these functions might be used:\n\n```solidity\ncontract MyContract is Context {\n    function doSomething() public {\n        address sender = _msgSender();\n        bytes memory data = _msgData();\n        // ... (use sender and data)\n    }\n}\n```\n\nIn this example, `MyContract` inherits from `Context` and can use `_msgSender()` and `_msgData()` to access the transaction's sender and data in a safe, abstracted way.","metadata":{"source":".autodoc/docs/markdown/contracts/Context.md"}}],["2",{"pageContent":"[View code on GitHub](https://github.com/LaGuerrePiece/moonolith/blob/master/contracts/IERC20.sol)\n\nThis Solidity code defines an interface for a token that complies with the ERC20 standard, a widely accepted standard for fungible tokens on the Ethereum blockchain. This interface, `IERC20`, outlines the necessary methods and events that any ERC20 token should implement.\n\nThe `totalSupply` method returns the total amount of tokens in existence. The `balanceOf` method returns the amount of tokens owned by a specific account. The `transfer` method moves a specified amount of tokens from the caller's account to a recipient's account, emitting a `Transfer` event upon success.\n\nThe `allowance` method returns the remaining number of tokens that a spender is allowed to spend on behalf of an owner. The `approve` method sets a specified amount as the allowance of a spender over the caller's tokens, emitting an `Approval` event upon success. It's important to note that changing an allowance with this method can potentially allow someone to use both the old and new allowance due to transaction ordering.\n\nThe `transferFrom` method moves a specified amount of tokens from a sender to a recipient using the allowance mechanism, deducting the transferred amount from the caller's allowance and emitting a `Transfer` event upon success.\n\nThe `Transfer` event is emitted when tokens are moved from one account to another, and the `Approval` event is emitted when the allowance of a spender for an owner is set. Both events can be used to track token movements and changes in allowances.","metadata":{"source":".autodoc/docs/markdown/contracts/IERC20.md"}}],["3",{"pageContent":"[View code on GitHub](https://github.com/LaGuerrePiece/moonolith/blob/master/contracts/Ownable.sol)\n\nThe `Ownable` contract in the Moonolith project is a Solidity contract that provides a basic access control mechanism. This mechanism allows an account, referred to as the owner, to have exclusive access to specific functions within the contract. \n\nThe contract is initialized with the deployer of the contract as the initial owner. This is done in the constructor function, which calls the `_setOwner` function with the `_msgSender` (the account that initiated the current function call) as the argument.\n\nThe contract provides a `onlyOwner` modifier, which can be used to restrict the use of certain functions to the owner of the contract. This is done by requiring that the caller of the function is the owner, otherwise an error message is thrown.\n\nThe contract also provides functionality to transfer ownership to a new account with the `transferOwnership` function. This function can only be called by the current owner and requires that the new owner is not the zero address. The function calls the `_setOwner` function to update the owner and emits an `OwnershipTransferred` event.\n\nThe `renounceOwnership` function allows the current owner to relinquish ownership of the contract. This function also can only be called by the current owner and sets the owner to the zero address. \n\nHere is an example of how the `onlyOwner` modifier could be used in a function within a contract that inherits from `Ownable`:\n\n```solidity\nfunction exclusiveFunction() public onlyOwner {\n    // Functionality here\n}\n```\n\nIn this example, `exclusiveFunction` can only be called by the owner of the contract.","metadata":{"source":".autodoc/docs/markdown/contracts/Ownable.md"}}],["4",{"pageContent":"[View code on GitHub](https://github.com/LaGuerrePiece/moonolith/blob/master/contracts/SafeMath.sol)\n\nThe `SafeMath` library in this Solidity code provides a set of functions for performing mathematical operations with built-in overflow and underflow checks. These checks are crucial in preventing common bugs in smart contracts that could be exploited by attackers. \n\nThe library includes functions for addition (`tryAdd`, `add`), subtraction (`trySub`, `sub`), multiplication (`tryMul`, `mul`), division (`tryDiv`, `div`), and modulus (`tryMod`, `mod`). Each operation has a `try` version that returns a boolean flag indicating whether the operation was successful, along with the result. This allows developers to handle potential errors in a more granular way.\n\nFor example, `tryAdd(uint256 a, uint256 b)` attempts to add `a` and `b` together. If the operation overflows, it returns `false` and `0`. If it doesn't overflow, it returns `true` and the result of the addition.\n\nThe non-`try` versions of the functions (`add`, `sub`, `mul`, `div`, `mod`) revert the transaction if an overflow or underflow occurs. This is a more drastic way of handling errors, but it ensures that transactions cannot result in an invalid state.\n\nThe library also includes versions of `sub`, `div`, and `mod` that accept a custom error message. These are deprecated because they require unnecessary memory allocation for the error message.\n\nIn the larger project, this library would be used wherever mathematical operations are performed to ensure that these operations do not result in overflows or underflows.","metadata":{"source":".autodoc/docs/markdown/contracts/SafeMath.md"}}],["5",{"pageContent":"[View code on GitHub](https://github.com/LaGuerrePiece/moonolith/blob/master/contracts/Strings.sol)\n\nThe provided code is a Solidity library named `Strings` that provides utility functions for string operations. Solidity is a statically-typed programming language primarily used for writing smart contracts on Ethereum-based blockchain platforms. \n\nThe `Strings` library contains three functions: `toString`, `toHexString`, and an overloaded version of `toHexString`. \n\nThe `toString` function takes a `uint256` as an argument and returns its ASCII string decimal representation. This function is useful when there is a need to represent a number in a human-readable format. For example, `toString(123)` would return the string `\"123\"`.\n\nThe `toHexString` function converts a `uint256` to its ASCII string hexadecimal representation. This function is useful when there is a need to represent a number in hexadecimal format. For example, `toHexString(255)` would return the string `\"0xff\"`.\n\nThe overloaded `toHexString` function takes two arguments: a `uint256` value and a `uint256` length. It converts the `uint256` value to its ASCII string hexadecimal representation with a fixed length. This function is useful when there is a need to represent a number in hexadecimal format with a specific length. For example, `toHexString(255, 2)` would return the string `\"0x00ff\"`.\n\nThese functions are marked as `internal`, meaning they can only be called from within the contract or contracts that derive from it. They are also marked as `pure`, meaning they do not modify or read from the blockchain state.","metadata":{"source":".autodoc/docs/markdown/contracts/Strings.md"}}],["6",{"pageContent":"[View code on GitHub](https://github.com/LaGuerrePiece/moonolith/tree/master/.autodoc/docs/json/contracts)\n\nThe `contracts` folder in the Moonolith project contains a collection of Solidity libraries, contracts, and interfaces that provide core functionalities for the project. \n\nThe `Base64.sol` library provides a function for base64 encoding of bytes. This is useful for converting binary data into a string format that can be easily transmitted over systems designed to handle text. For example, it can be used to encode data before sending it over a network.\n\nThe `Context.sol` contract provides information about the current execution context, including the sender of the transaction and its data. This is useful in scenarios where the account sending and paying for execution may not be the actual sender, such as in meta-transactions.\n\nThe `IERC20.sol` interface defines the necessary methods and events for an ERC20 token. This is a widely accepted standard for fungible tokens on the Ethereum blockchain. Any contract implementing this interface can be interacted with as an ERC20 token.\n\nThe `Ownable.sol` contract provides a basic access control mechanism, where an account, referred to as the owner, has exclusive access to specific functions. This can be used to restrict certain operations to the owner of a contract.\n\nThe `SafeMath.sol` library provides functions for performing mathematical operations with built-in overflow and underflow checks. This is crucial in preventing common bugs in smart contracts that could be exploited by attackers.\n\nThe `Strings.sol` library provides utility functions for string operations. This is useful for converting numbers to their string representations in decimal or hexadecimal format.\n\nThese libraries, contracts, and interfaces can be used together to build complex smart contracts. For example, a contract could inherit from `Ownable` to restrict certain operations to the owner, use `SafeMath` for safe mathematical operations, and use `Strings` for string operations. It could also implement the `IERC20` interface to behave as an ERC20 token, and use `Context` to handle meta-transactions.","metadata":{"source":".autodoc/docs/markdown/contracts/summary.md"}}],["7",{"pageContent":"[View code on GitHub](https://github.com/LaGuerrePiece/moonolith/blob/master/index.html)\n\nThe provided code is the main HTML file for the Moonolith project. It serves as the entry point for the application and is typically the first file that is loaded when the application is accessed by a user.\n\nThe `<!DOCTYPE html>` declaration at the top of the file is used to inform the browser about the version of HTML used in the document. The `<html lang=\"en\">` tag specifies that the language of this document is English.\n\nThe `<head>` section contains meta-information about the HTML document. The `<meta charset=\"UTF-8\" />` tag specifies the character encoding for the document, which is UTF-8 in this case. The `<link rel=\"icon\" href=\"/favicon.ico\" />` tag is used to specify a favicon for the webpage, which is typically displayed in the browser's address bar or next to the page's name in a list of bookmarks. The `<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />` tag is used for responsive web design. It sets the width of the page to follow the screen-width of the device (which will vary depending on the device). The `<title>` tag defines the title of the document, which is displayed in the browser's title bar or tab.\n\nThe `<body style=\"margin: 0; padding: 0\">` tag defines the body of the document. The style attribute is used to remove the default margin and padding from the body element.\n\nThe `<script type=\"module\" src=\"./src/main.js\"></script>` tag is used to include the JavaScript file `main.js` from the `src` directory. The `type=\"module\"` attribute is used to indicate that the script should be treated as an ECMAScript module. This means that the script can import functions, objects or values from other modules using the `import` statement. \n\nIn the context of the larger project, this HTML file would be used to structure the application, link to necessary resources (like CSS and JavaScript files), and set up the initial user interface.","metadata":{"source":".autodoc/docs/markdown/index.md"}}],["8",{"pageContent":"[View code on GitHub](https://github.com/LaGuerrePiece/moonolith/blob/master/server/index.html)\n\nThis HTML file serves as the basic structure for a web page in the Moonolith project. The `<!DOCTYPE html>` declaration at the top of the file is used to inform the web browser about the version of HTML the page is written in. The `<html lang=\"en\">` tag specifies that the language of this document is English.\n\nThe `<head>` section contains meta-information about the document. The `<meta charset=\"UTF-8\">` tag specifies the character encoding for the web page, which is UTF-8. The `<meta http-equiv=\"X-UA-Compatible\" content=\"IE=11\" />` tag is used to define the document compatibility mode in IE 11. The `<meta http-equiv=\"Cache-Control\" content=\"no-cache\" />` tag is used to prevent the browser from caching the document.\n\nThe `<meta http-equiv=\"Content-Security-Policy\" content=\"default-src 'self'; style-src 'self';\" />` tag is used to control resources the user agent is allowed to load, providing a measure of protection against cross-site scripting attacks. It restricts all the sources to be loaded from the same origin ('self').\n\nThe `<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">` tag is used for responsive web design. It sets the width of the page to follow the screen-width of the device (which will vary depending on the device), and the initial zoom level when the page is first loaded by the browser.\n\nThe `<title>` tag defines the title of the document, which is 'sender de liste v1.0'. This title is displayed in the browser's title bar or tab.\n\nThe `<body>` tag contains the content of the document. In this case, it is currently empty. This is where the main content of the web page would be added.","metadata":{"source":".autodoc/docs/markdown/server/index.md"}}],["9",{"pageContent":"[View code on GitHub](https://github.com/LaGuerrePiece/moonolith/blob/master/server/liste.txt)\n\nThe provided code does not seem to be a valid code in any known programming language. It appears to be a list of words or phrases in different languages: \"Bonjour\" is French for \"Hello\", \"Kikooe\" could be a misspelling of \"Kikou\" which is a French slang greeting, and \"Arigato\" is Japanese for \"Thank you\". \"TEST\" is a common placeholder or test string in many programming contexts.\n\nWithout additional context or valid code, it's impossible to provide a detailed technical explanation or high-level purpose of this code. It could potentially be used for a multi-language greeting system or a language translation feature in the larger project, but this is purely speculative based on the provided information.\n\nPlease provide valid code for a more accurate and detailed explanation.","metadata":{"source":".autodoc/docs/markdown/server/liste.md"}}],["10",{"pageContent":"[View code on GitHub](https://github.com/LaGuerrePiece/moonolith/tree/master/.autodoc/docs/json/server)\n\nThe `.autodoc/docs/json/server` folder in the Moonolith project contains two files: `index.html` and `liste.txt`.\n\n`index.html` is a basic HTML file that sets up the structure for a web page. It includes several meta tags for specifying the document's language, character encoding, compatibility mode, cache control, content security policy, and viewport settings. The title of the document is set to 'sender de liste v1.0'. The body of the document is currently empty, indicating that the main content of the web page is yet to be added. This file could serve as the main interface for the server-side of the Moonolith project, possibly providing a user interface for interacting with the server or displaying server-related information.\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=11\" />\n    <meta http-equiv=\"Cache-Control\" content=\"no-cache\" />\n    <meta http-equiv=\"Content-Security-Policy\" content=\"default-src 'self'; style-src 'self';\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>sender de liste v1.0</title>\n</head>\n<body>\n</body>\n</html>\n```\n\n`liste.txt` contains a list of words or phrases in different languages. Although it's not valid code, it could potentially be used for a multi-language greeting system or a language translation feature in the larger project. For example, these phrases could be displayed to the user based on their language settings or used for testing the project's internationalization features.\n\n```\nBonjour\nKikooe\nArigato\nTEST\n```\n\nIn conclusion, the `index.html` file could be the starting point for the server-side interface of the Moonolith project, while `liste.txt` could be used for language-related features or testing.","metadata":{"source":".autodoc/docs/markdown/server/summary.md"}}],["11",{"pageContent":"[View code on GitHub](https://github.com/LaGuerrePiece/moonolith/blob/master/src/assets/sounds.js)\n\nThis code is responsible for managing the audio functionality in the Moonolith project. It handles the playing, pausing, and muting of two specific audio files, `theEndOfTheWorld.mp3` and `rumble.mp3`, as well as any other audio file specified by name.\n\nThe `toggleMute` function switches the mute state. If the audio is currently muted, it will play the music; if not, it will pause both the music and the rumble sound.\n\nThe `playSound` function plays a specified sound, but only if the system is not muted and a certain time limit has passed since the last sound was played. This prevents rapid, overlapping sound playback.\n\nThe `toggleMusic` function switches the music between playing and paused states, while `playMusic` simply plays the music.\n\nThe `stopSound` function pauses a specified sound.\n\nThe `toggleRumble` function switches the rumble sound between playing and fading out, unless the system is muted. The fading out is handled by the `fadeAudio` function, which gradually reduces the volume of the sound over a period of 5 seconds before pausing it.\n\nHere's an example of how to use these functions:\n\n```javascript\nimport { toggleMute, playSound, stopSound } from './audioManager';\n\n// Mute or unmute all sounds\ntoggleMute();\n\n// Play a sound named 'explosion', but only if at least 1000ms have passed since the last sound was played\nplaySound('explosion', 1000);\n\n// Stop the 'explosion' sound\nstopSound('explosion');\n```\n\nThis audio management functionality could be used in a variety of ways within the Moonolith project, such as providing background music, sound effects for user actions, or auditory feedback for system events.","metadata":{"source":".autodoc/docs/markdown/src/assets/sounds.md"}}],["12",{"pageContent":"[View code on GitHub](https://github.com/LaGuerrePiece/moonolith/tree/master/.autodoc/docs/json/src/assets)\n\nThe `.autodoc/docs/json/src/assets` folder in the Moonolith project contains the `sounds.js` file which is responsible for managing the audio functionality of the project. This includes playing, pausing, and muting audio files, specifically `theEndOfTheWorld.mp3` and `rumble.mp3`, as well as any other audio file specified by name.\n\nThe `sounds.js` file contains several functions that control the audio behavior:\n\n- `toggleMute`: Switches the mute state. If the audio is currently muted, it will play the music; if not, it will pause both the music and the rumble sound.\n- `playSound`: Plays a specified sound, but only if the system is not muted and a certain time limit has passed since the last sound was played. This prevents rapid, overlapping sound playback.\n- `toggleMusic`: Switches the music between playing and paused states.\n- `playMusic`: Simply plays the music.\n- `stopSound`: Pauses a specified sound.\n- `toggleRumble`: Switches the rumble sound between playing and fading out, unless the system is muted. The fading out is handled by the `fadeAudio` function, which gradually reduces the volume of the sound over a period of 5 seconds before pausing it.\n\nHere's an example of how to use these functions:\n\n```javascript\nimport { toggleMute, playSound, stopSound } from './audioManager';\n\n// Mute or unmute all sounds\ntoggleMute();\n\n// Play a sound named 'explosion', but only if at least 1000ms have passed since the last sound was played\nplaySound('explosion', 1000);\n\n// Stop the 'explosion' sound\nstopSound('explosion');\n```\n\nThis audio management functionality could be used in a variety of ways within the project, such as providing background music, sound effects for user actions, or auditory feedback for system events. It is a crucial part of the user experience, enhancing the interactivity and responsiveness of the project.","metadata":{"source":".autodoc/docs/markdown/src/assets/summary.md"}}],["13",{"pageContent":"[View code on GitHub](https://github.com/LaGuerrePiece/moonolith/blob/master/src/constants.js)\n\nThe `Const` class in this file serves as a central repository for various constants and configuration values used throughout the Moonolith project. These constants include dimensions, colors, and other settings that are used to control the appearance and behavior of the application.\n\nThe class includes static getter methods for various properties such as `COLUMNS`, `LINES`, `MARGIN_TOP`, `MARGIN_BOTTOM`, `MARGIN_LEFT`, `MARGIN_RIGHT`, and others. These properties define the layout and dimensions of the application's interface. For example, `COLUMNS` and `LINES` define the size of the application's grid, while the `MARGIN_*` properties define the size of the margins around the grid.\n\nThe `setMonolithHeight` method allows the height of the monolith to be set dynamically. This could be used, for example, to adjust the size of the monolith based on user input or other factors.\n\nThe class also includes a series of color definitions in the form of RGB values. These colors are used throughout the application to ensure a consistent look and feel. The `PALETTE` and `GUI_PALETTE` properties return arrays of these colors, which could be used, for example, to populate a color picker in the application's interface.\n\nFinally, the `PARALLAX_LAYERS` and `PALETTE_INFO` properties provide configuration values for more complex features of the application. `PARALLAX_LAYERS` defines the behavior of different layers in a parallax scrolling effect, while `PALETTE_INFO` provides configuration values for different versions of the application's color palette.\n\nHere's an example of how these constants might be used in the application:\n\n```javascript\nimport Const from './Const';\n\n// Set the height of the monolith\nConst.setMonolithHeight(500);\n\n// Get the total number of lines in the grid\nlet totalLines = Const.LINES;\n\n// Get the color for the sky\nlet skyColor = Const.SKY_COLOR;\n```\n\nThis structure centralizes the configuration of the application, making it easier to manage and modify as the project evolves.","metadata":{"source":".autodoc/docs/markdown/src/constants.md"}}],["14",{"pageContent":"[View code on GitHub](https://github.com/LaGuerrePiece/moonolith/blob/master/src/display/FAQ.js)\n\nThe code in this file is primarily concerned with the display and management of a Frequently Asked Questions (FAQ) feature within the Moonolith project. It imports several dependencies from other modules, including view controls, image resources, GUI elements, and device controls.\n\nThe `FAQCatalog` object defines different layers of the FAQ view, each with a name, parallax effect, and starting position. The `displayFAQ` function is used to open the FAQ view, setting the FAQ type, zooming the view, and adjusting the GUI accordingly. If the device type is mobile, it also enables pan mode.\n\nThe `drawFAQ` function is responsible for rendering the FAQ view. It iterates over each layer in the `FAQCatalog`, calculates its position based on the parallax effect and current view position, and draws the corresponding image from the image catalog. If the layer is the FAQ layer, it also draws clouds. Finally, it draws the close button for the FAQ.\n\nThe `exitFAQ` function is used to close the FAQ view, resetting the view position and FAQ state.\n\nThe `drawClouds` function is a helper function used to draw cloud images onto the FAQ view. It iterates over the image catalog, skipping any images that are not of type 'cloud', calculates their position based on a parallax effect and the current view position, and draws them onto the view.\n\nHere's an example of how these functions might be used in the larger project:\n\n```javascript\nimport { displayFAQ, exitFAQ } from './FAQ';\n\n// Open the FAQ to the 'stars' section\ndisplayFAQ('stars');\n\n// ... user interacts with FAQ ...\n\n// Close the FAQ\nexitFAQ();\n```\n\nThis code would open the FAQ to the 'stars' section, allow the user to interact with it, and then close the FAQ when done.","metadata":{"source":".autodoc/docs/markdown/src/display/FAQ.md"}}],["15",{"pageContent":"[View code on GitHub](https://github.com/LaGuerrePiece/moonolith/blob/master/src/display/animations.js)\n\nThis code is responsible for managing animations in the Moonolith project. It imports various assets and constants, and defines an animation catalog (`animCatalog`) that contains information about each animation, such as its type, start position, whether it should be displayed and looped, its layer, and its base64 representation.\n\nThe `animFrameManager` function manages the frames of a given animation. It checks if the animation is of type 'intro' and if the intro state is false, it sets the display of the animation to false. It then sets a timeout to update the current frame of the animation. If the animation is set to loop, it resets the current frame to 0 and calls `animFrameManager` again.\n\nThe `launchAnim` function sets the display of a given animation to true and calls `animFrameManager` to start managing its frames.\n\nThe `updateAnimCatalog` function updates the x and y positions of each animation in the catalog based on the current view position and other constants. It also adjusts the positions of the 'postMonolith' and 'autourDuFeu' animations.\n\nThe `drawAnimations` function draws the current frame of each animation in the catalog that is set to display and is on the given layer. It calls the `drawFrame` function to draw each frame.\n\nThe `drawFrame` function creates an image data object from the current frame of the given animation and draws it on the animation's canvas. It then draws the animation's canvas on the given context at the animation's current position.\n\nThe `loadAnims` function initializes each animation in the catalog. It creates a canvas for each animation, sets its width and height, sets its parallax based on its layer, and sets its current frame to 0. If the animation is of type 'continual', it launches the animation. It also adjusts the start y position of the 'collision' animation.","metadata":{"source":".autodoc/docs/markdown/src/display/animations.md"}}],["16",{"pageContent":"[View code on GitHub](https://github.com/LaGuerrePiece/moonolith/blob/master/src/display/pointer.js)\n\nThe code in this file is primarily concerned with the manipulation of a data structure referred to as `monolithData`. This data structure appears to represent a monolith, a large structure within the Moonolith project. The main function, `addPointer`, modifies the `monolithData` based on the position of a pointer and the selected tool.\n\nThe `addPointer` function first checks if the device type is 'mobile'. If it is, the function immediately returns the unmodified `monolithData`. If the device is not mobile, the function proceeds to modify the `monolithData` based on the selected tool ('smol', 'medium', 'large', or 'giga') and the position of the pointer. The modification is done by calling the `whiten` function, which appears to lighten or \"whiten\" the specified area of the monolith.\n\nThe `whiten` function takes in the `monolithData` and coordinates (x, y). It first checks if the coordinates are within the valid range. If they are not, the function returns without making any changes. If the coordinates are valid, the function calculates the position on the monolith and checks if the area is editable. If it is, the function lightens the color of the specified area by increasing the RGB values.\n\nThis code could be used in the larger project to allow users to interact with the monolith, possibly as part of a drawing or editing feature. The different tools ('smol', 'medium', 'large', 'giga') likely correspond to different sizes or intensities of the editing effect.","metadata":{"source":".autodoc/docs/markdown/src/display/pointer.md"}}],["17",{"pageContent":"[View code on GitHub](https://github.com/LaGuerrePiece/moonolith/tree/master/.autodoc/docs/json/src/display)\n\nThe `display` folder in the Moonolith project contains code that manages the display and interaction of various elements within the project, such as FAQs, animations, and a monolith structure.\n\nThe `FAQ.js` file manages the FAQ feature. It defines the FAQ view layers and controls the display, rendering, and exit of the FAQ view. For example, to open the FAQ to a specific section and then close it, you might use:\n\n```javascript\nimport { displayFAQ, exitFAQ } from './FAQ';\ndisplayFAQ('stars');\n// ... user interacts with FAQ ...\nexitFAQ();\n```\n\nThe `animations.js` file handles animations. It defines an animation catalog and functions to manage animation frames, launch animations, update animation positions, draw animations, and initialize animations. For instance, to launch an animation, you would use the `launchAnim` function.\n\nThe `pointer.js` file manipulates a data structure representing a monolith. The `addPointer` function modifies the monolith based on the position of a pointer and the selected tool, while the `whiten` function lightens a specified area of the monolith. This could be part of a feature allowing users to interact with the monolith, using different tools to create different effects.\n\nIn summary, the `display` folder contains code that controls various visual and interactive elements of the Moonolith project. It manages the display of FAQs and animations, and allows user interaction with a monolith structure.","metadata":{"source":".autodoc/docs/markdown/src/display/summary.md"}}],["18",{"pageContent":"[View code on GitHub](https://github.com/LaGuerrePiece/moonolith/blob/master/src/intro.js)\n\nThe code in this file is primarily responsible for managing the introduction sequence of the Moonolith project. It imports various modules and functions from other files in the project, such as animations, images, controls, and display settings.\n\nThe `launchIntro` function is the main function that initiates the introduction sequence. It sets the initial view position, initializes the display, and triggers the 'collision' animation. It then changes the view position smoothly and launches a series of animations in sequence, each one waiting for the previous one to complete before starting. The function also handles the display of certain images at specific points in the sequence.\n\nThe `skipIntro` function allows the user to skip the introduction sequence. It hides certain animations and images, unlocks the scroll, and launches the 'autourDuFeu' animation. It also resets the view position to its initial state.\n\nThe `finalSkip` function is called at the end of the introduction sequence or when the user chooses to skip the intro. It hides the 'skipIntro' button, displays the 'faqButtonOpen' if it's the user's first time, toggles the music, unlocks the controls, and displays the 'panneau' and 'palette'.\n\nThe `monolithGoUpDuringIntro` function is responsible for creating an effect of the monolith rising during the introduction sequence. It increments the `monolithDisplayHeightIntro` variable over time, creating a visual effect of the monolith rising.\n\nThe `displayPanneau` function displays a panel with instructions for the user. It checks the user's browser language and displays the appropriate image. It also launches the 'panneauRainbow' animation and displays the 'panneauDecor' image.","metadata":{"source":".autodoc/docs/markdown/src/intro.md"}}],["19",{"pageContent":"[View code on GitHub](https://github.com/LaGuerrePiece/moonolith/blob/master/src/main.js)\n\nThe code in this file primarily handles the initialization and dynamic updates of a web application, presumably a visual display of a monolith structure. \n\nThe `initApp` function is the main entry point. It sets up the application's state and decides whether to launch an intro sequence or skip it based on the `firstTime` and `Opensea` variables. The `setRoute` function is used to parse the URL and set the `Opensea` and `runeNumber` variables, and also sets a cookie to track if the user has visited the site before.\n\nThe `chunkImport` and `importNewChunks` functions are responsible for fetching and processing \"chunks\" of data, which are then displayed on the monolith. These chunks are fetched from a Web3-based source, as indicated by the imported `getChunk`, `getMetaData`, and `getAllChunks` functions from `./utils/web3`. The chunks are then processed and displayed on the monolith using the `bufferOnMonolith` function.\n\nThe `setMonoHeightAndBuildIt` function fetches metadata, calculates the height of the monolith based on this metadata, and then builds the monolith using the `buildMonolith` function. It also initializes some visual elements with the `initClouds` function.\n\nThe code also sets up a recurring interval to call `importNewChunks` every 30 seconds, ensuring that the monolith display is kept up-to-date with the latest data.\n\n```javascript\nsetInterval(() => {\n    importNewChunks();\n}, 30000);\n```\n\nOverall, this code is responsible for initializing the application, fetching and processing data to be displayed on the monolith, and updating this display at regular intervals.","metadata":{"source":".autodoc/docs/markdown/src/main.md"}}],["20",{"pageContent":"[View code on GitHub](https://github.com/LaGuerrePiece/moonolith/blob/master/src/monolith/monolithAnims.js)\n\nThe code in this file is primarily responsible for animating the monolith and its runes in the Moonolith project. It imports several dependencies, including constants, monolith data, and display parameters. It also exports two variables and two functions that can be used by other parts of the project.\n\nThe `animateMonolith` function is the main function in this file. It iterates over the `chunksToAnimateInfo` object and triggers the `animateRune` function for visible chunks. It also iterates over the `animatedPixels` Map and performs different animations based on the `transitionType` of each pixel. The animations include erasing, drawing, importing, and various types of rune animations. Each animation changes the color of the pixel over a certain number of steps, and ends the transition when the counter reaches a certain value.\n\nThe `draw` function changes the color of a pixel in the monolith. The `endTransition` function ends the transition of a pixel by drawing it with the final color and removing it from the `animatedPixels` Map. The `avg` function calculates the average color between a given color and the current color of a pixel in the monolith.\n\nThe `animateRune` function is triggered only once per rune. It displays the rune and starts a white-on-rune animation after a delay. It also starts a rune contour animation for each pixel in the rune.\n\nHere is an example of how to use the `animateMonolith` function:\n\n```javascript\nimport { animateMonolith } from './monolithAnimation';\n\n// Populate chunksToAnimateInfo and animatedPixels\n// ...\n\n// Animate the monolith\nanimateMonolith();\n```\n\nAnd here is an example of how to use the `animateRune` function:\n\n```javascript\nimport { animateRune } from './monolithAnimation';\n\n// Populate chunkStock and chunksToAnimateInfo\n// ...\n\n// Animate a rune with id 1\nanimateRune(1);\n```","metadata":{"source":".autodoc/docs/markdown/src/monolith/monolithAnims.md"}}],["21",{"pageContent":"[View code on GitHub](https://github.com/LaGuerrePiece/moonolith/tree/master/.autodoc/docs/json/src/monolith)\n\nThe `monolith` folder in the `src` directory of the Moonolith project contains JavaScript files that manage the animation, drawing tools, and undo/redo functionality for the monolith structure.\n\nThe `monolithAnims.js` file handles the animation of the monolith and its runes. It provides functions like `animateMonolith` and `animateRune` to animate the entire monolith or individual runes. These functions can be used as follows:\n\n```javascript\nimport { animateMonolith, animateRune } from './monolithAnimation';\n\n// Animate the monolith\nanimateMonolith();\n\n// Animate a rune with id 1\nanimateRune(1);\n```\n\nThe `tools.js` file manages the drawing tools for the project. It provides functions to start using a tool, switch between tools, and change the color of the tools. Here's an example of how these functions might be used:\n\n```javascript\nstartUsingTool(e, mousePos); // Start using a tool\nbrushSwitch(); // Switch to the next tool\nselectBrush('large'); // Select the 'large' tool\ncolorSwitch(e, 5); // Switch to color 5\n```\n\nThe `undoStack.js` file provides a system to track changes to the monolith and undo or redo them if necessary. It uses two stacks, `eventStack` and `inverseEventStack`, to store the changes. Here's an example of how these functions might be used:\n\n```javascript\naddToCurrentEvent(5, 5, [255, 0, 0], 1); // Add a change to the current event\ncloseCurrentEvent(); // Close the current event\nundo(); // Undo the last event\nredo(); // Redo the last undone event\n```\n\nThese files work together to provide a rich user experience for interacting with the monolith. They allow for animating the monolith, drawing on it with different tools and colors, and undoing or redoing changes.","metadata":{"source":".autodoc/docs/markdown/src/monolith/summary.md"}}],["22",{"pageContent":"[View code on GitHub](https://github.com/LaGuerrePiece/moonolith/blob/master/src/monolith/tools.js)\n\nThe code in this file is primarily responsible for managing the drawing tools in the Moonolith project. It provides functionality for selecting and using different tools, changing the color of the tools, and interacting with the canvas.\n\nThe `startUsingTool` function is the entry point for using a tool. It sets up the necessary event listeners on the canvas and determines which tool to use based on the mouse button pressed. The `useTool` function is called whenever the mouse is moved, and it draws on the canvas based on the current tool and color.\n\nThe `brushSwitch` and `selectBrush` functions allow for changing the current tool. The `brushSwitch` function cycles through the available tools, playing a sound each time the tool is changed. The `selectBrush` function allows for directly selecting a tool.\n\nThe `colorPicker` and `colorSwitch` functions manage the color of the tools. The `colorPicker` function picks a color from the canvas based on the mouse position. The `colorSwitch` function changes the current color based on the mouse button pressed and the color passed in.\n\nHere's an example of how these functions might be used:\n\n```javascript\nstartUsingTool(e, mousePos); // Start using a tool\nbrushSwitch(); // Switch to the next tool\nselectBrush('large'); // Select the 'large' tool\ncolorSwitch(e, 5); // Switch to color 5\n```\n\nThis code is crucial for the user interaction with the canvas in the Moonolith project. It allows for drawing on the canvas with different tools and colors, and provides feedback through sounds.","metadata":{"source":".autodoc/docs/markdown/src/monolith/tools.md"}}],["23",{"pageContent":"[View code on GitHub](https://github.com/LaGuerrePiece/moonolith/blob/master/src/monolith/undoStack.js)\n\nThis code is part of a system that manages changes to a monolith, a large structure that is represented as a 2D array of pixels. The monolith can be modified by changing the color and z-index of its pixels. The code provides a way to track these changes and undo or redo them if necessary.\n\nThe changes are stored in two stacks: `eventStack` and `inverseEventStack`. Each item in these stacks is an event, which is a list of changes. A change is represented as an object with properties `x`, `y`, `oldColor`, and `oldZIndex`, which represent the pixel's coordinates, its previous color, and its previous z-index, respectively.\n\nThe `addToCurrentEvent` function is used to add a change to the current event. When an event is completed, the `closeCurrentEvent` function is called to push the current event to the `eventStack` and clear the current event and `inverseEventStack`.\n\nThe `undo` function pops the last event from the `eventStack`, applies the changes in reverse, and pushes the reversed changes to the `inverseEventStack`. The `redo` function does the opposite: it pops the last event from the `inverseEventStack`, applies the changes, and pushes them to the `eventStack`.\n\nFor example, if a pixel at (5, 5) was changed from red to blue, the change would be added to the current event with `addToCurrentEvent(5, 5, [255, 0, 0], 1)`. When the changes are done, `closeCurrentEvent` would be called. If the user wants to undo the change, they would call `undo()`, which would change the pixel back to red and add the change to the `inverseEventStack`. If they then call `redo()`, the pixel would be changed back to blue and the change would be added back to the `eventStack`.","metadata":{"source":".autodoc/docs/markdown/src/monolith/undoStack.md"}}],["24",{"pageContent":"[View code on GitHub](https://github.com/LaGuerrePiece/moonolith/tree/master/.autodoc/docs/json/src)\n\nThe `json/src` folder in the Moonolith project contains the core JavaScript files that manage the application's functionality. The `constants.js` file acts as a central repository for various constants and configuration values used throughout the project. This includes dimensions, colors, and other settings that control the appearance and behavior of the application. The `intro.js` file manages the introduction sequence of the project, while the `main.js` file handles the initialization and dynamic updates of the web application.\n\nThe `assets` subfolder contains the `sounds.js` file which manages the audio functionality of the project. This includes playing, pausing, and muting audio files. The `display` subfolder contains code that manages the display and interaction of various elements within the project, such as FAQs, animations, and a monolith structure. The `monolith` subfolder contains JavaScript files that manage the animation, drawing tools, and undo/redo functionality for the monolith structure. The `utils` subfolder contains utility functions for handling mouse interactions within the project.\n\nFor example, to animate the monolith or individual runes, you would use the `animateMonolith` or `animateRune` functions from the `monolithAnims.js` file in the `monolith` subfolder:\n\n```javascript\nimport { animateMonolith, animateRune } from './monolithAnimation';\n\n// Animate the monolith\nanimateMonolith();\n\n// Animate a rune with id 1\nanimateRune(1);\n```\n\nTo handle mouse interactions with various elements in the project, you would use the utility functions from the `conversions.js` file in the `utils` subfolder:\n\n```javascript\nlet gridPos = mousePosInGrid(mousePos, canvasPos, scaleFactor, pixelSize);\nlet monolithPos = convertToMonolithPos(mousePos, monolithPos, monolithSize);\n```\n\nOverall, the `json/src` folder contains the core functionality of the Moonolith project, providing a rich user experience for interacting with the monolith, managing the display of FAQs and animations, and handling audio functionality.","metadata":{"source":".autodoc/docs/markdown/src/summary.md"}}],["25",{"pageContent":"[View code on GitHub](https://github.com/LaGuerrePiece/moonolith/blob/master/src/utils/conversions.js)\n\nThe code in this file is primarily concerned with handling mouse interactions within the Moonolith project. It provides a set of utility functions that can be used to determine the position of the mouse within different contexts, such as within a grid, a circle, a square, or relative to a specific layer.\n\nThe `isInCircle` and `isInSquare` functions check if the mouse position is within a given circle or square, respectively. They first convert the mouse position to the coordinate system of a specified layer using the `convertToLayer` function, and then perform the geometric calculations. The `convertToLayer` function adjusts the coordinates based on the position of the specified layer, which can be an image, a GUI element, or an FAQ element.\n\nThe `mousePosInGrid` function calculates the mouse position within a grid. It first gets the position of the canvas element relative to the viewport, and then calculates the grid coordinates by subtracting the canvas position from the mouse position and dividing by the scale factor and pixel size.\n\nThe `convertToMonolithPos` function converts the mouse position to the coordinate system of the Monolith, which is a specific element within the project. It adjusts the coordinates based on the position and size of the Monolith, and returns `undefined` if the resulting position is outside the Monolith.\n\nThese functions can be used throughout the Moonolith project to handle mouse interactions with various elements, such as selecting an object, dragging and dropping, or hovering over an element to display a tooltip.","metadata":{"source":".autodoc/docs/markdown/src/utils/conversions.md"}}],["26",{"pageContent":"[View code on GitHub](https://github.com/LaGuerrePiece/moonolith/tree/master/.autodoc/docs/json/src/utils)\n\nThe `utils` folder in the `json/src` directory of the Moonolith project contains utility functions for handling mouse interactions within the project. These functions are encapsulated in the `conversions.js` file.\n\nThe `conversions.js` file provides a set of utility functions that determine the position of the mouse within different contexts. For instance, the `isInCircle` and `isInSquare` functions check if the mouse position is within a given circle or square, respectively. They first convert the mouse position to the coordinate system of a specified layer using the `convertToLayer` function, and then perform the geometric calculations. \n\n```javascript\nif (isInCircle(mousePos, circleCenter, radius)) {\n  // Mouse is within the circle\n}\n```\n\nThe `mousePosInGrid` function calculates the mouse position within a grid. It first gets the position of the canvas element relative to the viewport, and then calculates the grid coordinates by subtracting the canvas position from the mouse position and dividing by the scale factor and pixel size.\n\n```javascript\nlet gridPos = mousePosInGrid(mousePos, canvasPos, scaleFactor, pixelSize);\n```\n\nThe `convertToMonolithPos` function converts the mouse position to the coordinate system of the Monolith, a specific element within the project. It adjusts the coordinates based on the position and size of the Monolith, and returns `undefined` if the resulting position is outside the Monolith.\n\n```javascript\nlet monolithPos = convertToMonolithPos(mousePos, monolithPos, monolithSize);\nif (monolithPos !== undefined) {\n  // Mouse is within the Monolith\n}\n```\n\nThese functions are essential for handling mouse interactions with various elements in the Moonolith project, such as selecting an object, dragging and dropping, or hovering over an element to display a tooltip. They provide a consistent way to handle mouse positions and interactions across different parts of the project.","metadata":{"source":".autodoc/docs/markdown/src/utils/summary.md"}}],["27",{"pageContent":"[View code on GitHub](https://github.com/LaGuerrePiece/moonolith/blob/master/vite.config.js)\n\nThis code is a configuration file for Vite, a modern front-end build tool. It is written in JavaScript and uses ES6 import syntax to import necessary modules. \n\nThe purpose of this code is to define specific configurations for the Vite server and module resolution. The `defineConfig` function from Vite is used to export a configuration object. This object has two properties: `server` and `resolve`.\n\nThe `server` property is an object that contains configurations for the Vite development server. In this case, the `hmr` (Hot Module Replacement) property is set to `false`. This means that when a file is changed, the whole page will reload instead of just the changed module.\n\nThe `resolve` property is an object that contains configurations for module resolution. The `alias` property is used to define a shortcut for importing modules. In this case, the '@' symbol is mapped to the path of the 'src' directory. This allows developers to import modules from the 'src' directory using '@' instead of the relative path. For example, instead of writing `import MyComponent from '../../src/MyComponent'`, they can write `import MyComponent from '@/MyComponent'`.\n\nThe `fileURLToPath` and `URL` modules from the 'url' package are used to convert the URL of the 'src' directory to a file path. The `import.meta.url` property is a built-in feature in JavaScript modules that provides the URL of the current module.","metadata":{"source":".autodoc/docs/markdown/vite.config.md"}}]]